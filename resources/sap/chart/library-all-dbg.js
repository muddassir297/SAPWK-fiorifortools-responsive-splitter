// This file has been generated by the SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.chart.library-all');
if ( !jQuery.sap.isDeclared('sap.chart.ChartLog') ) {
/*
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.chart.ChartLog'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/ChartLog",[], function() {
	"use strict";

	function ChartLog(sType, sName, sMessage) {
		this._type = sType;
		this._name = sName;
		this._message = sMessage;
	}

	ChartLog.prototype.display = function() {
		if (this._type === "error") {
			jQuery.sap.log.error("[Error in user input] " + this._name, this._message, 'sap.chart');
		}
	};

	return ChartLog;
});
}; // end of sap/chart/ChartLog.js
if ( !jQuery.sap.isDeclared('sap.chart.ChartType') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

// Provides enumeration sap.chart.ChartType
jQuery.sap.declare('sap.chart.ChartType'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/ChartType",function() {
    "use strict";


    /**
    * Enumeration for supported chart types in analytical chart
    *
    * @namespace
    * @public
    * @alias sap.chart.ChartType
    */
    var ChartType = {
        /**
         * Bar Chart
         * @public
         */
        Bar: "bar",
        /**
         * Column Chart
         * @public
         */
        Column: "column",
        /**
         * Line Chart
         * @public
         */
        Line: "line",
        /**
         * Combined Column Line Chart
         * @public
         */
        Combination: "combination",
        /**
         * Pie Chart
         * @public
         */
        Pie: "pie",
        /**
         * Donut Chart
         * @public
         */
        Donut: "donut",
        /**
         * Scatter Plot
         * @public
         */
        Scatter: "scatter",
        /**
         * Bubble Chart
         * @public
         */
        Bubble: "bubble",
        /**
         * Heat Map
         * @public
         */
        Heatmap: "heatmap",
        /**
         * Bubble Chart
         * @public
         */
        Bullet: "bullet",
        /**
         * Vertical Bullet Chart
         * @public
         */
        VerticalBullet: "vertical_bullet",
        /**
         * Stacked Bar Chart
         * @public
         */
        StackedBar: "stacked_bar",
        /**
         * Stacked Column Chart
         * @public
         */
        StackedColumn: "stacked_column",
        /**
         * Combined Stacked Line Chart
         * @public
         */
        StackedCombination: "stacked_combination",
        /**
         * Horizontal Combined Stacked Line Chart
         * @public
         */
        HorizontalStackedCombination: "horizontal_stacked_combination",
        /**
         * Bar Chart with 2 X-Axes
         * @public
         */
        DualBar: "dual_bar",
        /**
         * Column Chart with 2 Y-Axes
         * @public
         */
        DualColumn: "dual_column",
        /**
         * Line Chart with 2 Y-Axes
         * @public
         */
        DualLine: "dual_line",
        /**
         * Stacked Bar Chart with 2 X-Axes
         * @public
         */
        DualStackedBar: "dual_stacked_bar",
        /**
         * Stacked Column Chart with 2 Y-Axes
         * @public
         */
        DualStackedColumn: "dual_stacked_column",
         /**
         * Combined Column Line Chart with 2 Y-Axes
         * @public
         */
        DualCombination: "dual_combination",
         /**
         * Horizontal Combined Bar Line Chart with 2 X-Axes
         * @public
         */
        DualHorizontalCombination: "dual_horizontal_combination",
        /**
         * Combined Stacked Line Chart with 2 Y-Axes
         * @public
         */
        DualStackedCombination: "dual_stacked_combination",
        /**
         * Horizontal Combined Stacked Line Chart with 2 X-Axes
         * @public
         */
        DualHorizontalStackedCombination: "dual_horizontal_stacked_combination",
        /**
         * 100% Stacked Bar Chart
         * @public
         */
        PercentageStackedBar: "100_stacked_bar",
        /**
         * 100% Stacked Column Chart
         * @public
         */
        PercentageStackedColumn: "100_stacked_column",
        /**
         * 100% Stacked Bar Chart with 2 X-Axes
         * @public
         */
        PercentageDualStackedBar: "100_dual_stacked_bar",
        /**
         * 100% Stacked Column Chart with 2 Y-Axes
         * @public
         */
        PercentageDualStackedColumn: "100_dual_stacked_column",
        /**
         * Waterfall Chart
         * @public
         */
        Waterfall: "waterfall",
        /**
         * Horizontal Waterfall Chart
         * @public
         */
        HorizontalWaterfall: "horizontal_waterfall"
    };

    return ChartType;

}, /* bExport= */ true);

}; // end of sap/chart/ChartType.js
if ( !jQuery.sap.isDeclared('sap.chart.TimeUnitType') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

// Provides enumeration sap.chart.TimeUnitType
jQuery.sap.declare('sap.chart.TimeUnitType'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/TimeUnitType",function() {
    "use strict";


    /**
    * Enumeration for supported time unit types in analytical chart
    *
    * @namespace
    * @public
    * @alias sap.chart.TimeUnitType
    */
    var TimeUnitType = {
        /**
         * type is Edm.DateTime and V2 annotation sap:display-format is "Date" or timestamp
         * @public
         */
        Date: "Date",
        /**
         * type is Edm.string and V2 annotation sap:semantics is "yearmonthday", like "yyyyMMdd"
         * @public
         */
        yearmonthday: "yearmonthday",

        /**
         * type is Edm.string, like "yyyyQQQQQ"
         * @public
         */
        yearquarter: "yearquarter",

        /**
         * type is Edm.string, like "yyyyMM"
         * @public
         */
        yearmonth: "yearmonth",
	    /**
         * type is Edm.string, like "YYYY"
         * @public
         */
        fiscalyear: "fiscalyear",
        /**
         * type is Edm.string, like "YYYYPPP"
         * @public
         */
        fiscalyearperiod: "fiscalyearperiod"

    };


    return TimeUnitType;

}, /* bExport= */ true);

}; // end of sap/chart/TimeUnitType.js
if ( !jQuery.sap.isDeclared('sap.chart.coloring.ColorPalette') ) {
jQuery.sap.declare('sap.chart.coloring.ColorPalette'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/coloring/ColorPalette",[], function(
) {
	"use strict";
	var Palette = {};

	Palette.CRITICALITY = {
		Positive: [
		    'sapUiChartPaletteSemanticGoodLight3',
		    'sapUiChartPaletteSemanticGoodLight2',
		    'sapUiChartPaletteSemanticGoodLight1',
		    'sapUiChartPaletteSemanticGood',
		    'sapUiChartPaletteSemanticGoodDark1',
		    'sapUiChartPaletteSemanticGoodDark2'
		],
		Critical: [
			'sapUiChartPaletteSemanticCriticalLight3',
			'sapUiChartPaletteSemanticCriticalLight2',
			'sapUiChartPaletteSemanticCriticalLight1',
			'sapUiChartPaletteSemanticCritical',
			'sapUiChartPaletteSemanticCriticalDark1',
			'sapUiChartPaletteSemanticCriticalDark2'
		],
		Negative: [
			'sapUiChartPaletteSemanticBadLight3',
			'sapUiChartPaletteSemanticBadLight2',
			'sapUiChartPaletteSemanticBadLight1',
			'sapUiChartPaletteSemanticBad',
			'sapUiChartPaletteSemanticBadDark1',
			'sapUiChartPaletteSemanticBadDark2'
		],
		Neutral: [
			'sapUiChartPaletteSemanticNeutralLight3',
			'sapUiChartPaletteSemanticNeutralLight2',
			'sapUiChartPaletteSemanticNeutralLight1',
			'sapUiChartPaletteSemanticNeutral',
			'sapUiChartPaletteSemanticNeutralDark1',
			'sapUiChartPaletteSemanticNeutralDark2'
		]
	};

	Palette.EMPHASIS = {
		Highlight: "sapUiChartPaletteQualitativeHue2",
		Others: "sapUiChartPaletteQualitativeHue1"
	};

	return Palette;
});
}; // end of sap/chart/coloring/ColorPalette.js
if ( !jQuery.sap.isDeclared('sap.chart.coloring.ColoringUtils') ) {
jQuery.sap.declare('sap.chart.coloring.ColoringUtils'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/coloring/ColoringUtils",[], function(
) {
	"use strict";
	var type = jQuery.type;

	var Util = {};
	Util.find = function(sMsrName, aList) {
		for (var i = 0; i < aList.length; i++) {
			if (sMsrName === aList[i].getName()) {
				return aList[i];
			}
		}
		return null;
	};

	Util.isNumber = function() {
		for (var i = 0; i < arguments.length; i++) {
			if (type(arguments[i]) !== 'number') {
				return false;
			}
		}
		return true;
	};

	Util.assertLevel = function(oBreakdown, sLevelType) {
		var iLevel = oBreakdown[sLevelType];
		if (iLevel === null || iLevel === undefined) {
			return 1;
		} else if ([1, 2, 3, 4, 5, 6].indexOf(iLevel) !== -1) {
			return iLevel;
		} else {
			throw new Error("Colorings.Criticality.<MeasureName>.Breakdown." + sLevelType + " must be an integer from 1 to 6, received " + iLevel);
		}
	};

	Util.thresholdValue = function(oThreshold) {
		if (type(oThreshold) === 'string') {
			return function(oCtx) {
				return oCtx[oThreshold];
			};
		} else {
			return function(oCtx) {
				return oThreshold;
			};
		}
	};

	Util.isInRange = function(val, lo, hi, loInclusive, hiInclusive) {
		if (!Util.isNumber(val, lo, hi)) {
			return false;
		}
		var loTest = loInclusive ? (lo <= val) : (lo < val);
		var hiTest = hiInclusive ? (val <= hi) : (val < hi);

		return loTest && hiTest;
	};

	Util.genLevels = function(nLvls, fnLevels) {
		var aLevels = [];
		for (var i = 0; i < nLvls; i++) {
			aLevels.push(i + 1);
		}
		return aLevels.map(function(nLevel) {
			return function(oCtx) {
				return fnLevels(oCtx) === nLevel;
			};
		});
	};

	Util.assignColor = function(aColors, iLvls) {
		switch (iLvls) {
			case 1:
				return [aColors[3]];
			case 2:
				return [aColors[1], aColors[3]];
			case 3:
				return [aColors[1], aColors[3], aColors[5]];
			case 4:
				return aColors.slice(1, 5);
			case 5:
				return aColors.slice(1, 6);
			case 6:
				return aColors.slice(0, 6);
			default:
				return null;
		}
	};

	Util.assignUnmentionedColor = function(aColors, iLvls) {
		switch (iLvls) {
			case 1:
				return [aColors[1]];
			case 2:
				return [aColors[1], aColors[5]];
			case 3:
				return [aColors[1], aColors[2], aColors[4]];
			case 4:
				return [aColors[1], aColors[2], aColors[4], aColors[5]];
			case 5:
			    return aColors.filter(function(idx) {
				    return idx !== 3;
			    });
			default:
				return null;
		}
	};

	// Util.createRules = function(oRuleSetting, oMsr) {
	// 	var aRules = [];
	// 	jQuery.each(oRuleSetting.callbacks, function(sCategory, aCbs) {
	// 		var aColors = Palette.assignColor(Palette.COLORS[sCategory.toLowerCase()], aCbs.length);
	// 		jQuery.each(aCbs, function(idx, fnCb) {
	// 			var sDisplayName = [];
	// 			if (oMsr) {
	// 				sDisplayName.push(oMsr.getLabel() || oMsr.getName());
	// 			}
	// 			sDisplayName.push(sCategory.charAt(0).toUpperCase() + sCategory.slice(1));
	// 			sDisplayName = sDisplayName.join(' - ');
	// 			aRules.push({
	// 				callback: fnCb,
	// 				properties: {
	// 					color: aColors[idx]
	// 				},
	// 				displayName: aCbs.length > 1 ? (sDisplayName + ' ' + (idx + 1)) : sDisplayName
	// 			});
	// 		});
	// 	});
	// 	return aRules;
	// };

	return Util;
});

}; // end of sap/chart/coloring/ColoringUtils.js
if ( !jQuery.sap.isDeclared('sap.chart.utils.ChartUtils') ) {
/*
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */
jQuery.sap.declare('sap.chart.utils.ChartUtils'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/utils/ChartUtils",['sap/chart/ChartType'], function(ChartType) {
	"use strict";

	var _CONFIG = {
		chartTypes: [
			ChartType.Bar,
			ChartType.Column,
			ChartType.Line,
			ChartType.Combination,
			ChartType.Pie,
			ChartType.Donut,
			ChartType.Scatter,
			ChartType.Bubble,
			ChartType.Heatmap,
			ChartType.Bullet,
			ChartType.VerticalBullet,
			ChartType.StackedBar,
			ChartType.StackedColumn,
			ChartType.StackedCombination,
			ChartType.HorizontalStackedCombination,
			ChartType.DualBar,
			ChartType.DualColumn,
			ChartType.DualLine,
			ChartType.DualStackedBar,
			ChartType.DualStackedColumn,
			ChartType.DualCombination,
			ChartType.DualHorizontalCombination,
			ChartType.DualStackedCombination,
			ChartType.DualHorizontalStackedCombination,
			ChartType.PercentageStackedBar,
			ChartType.PercentageStackedColumn,
			ChartType.PercentageDualStackedBar,
			ChartType.PercentageDualStackedColumn,
			ChartType.Waterfall,
			ChartType.HorizontalWaterfall
		],
		pagingChartTypes: [
		    ChartType.Bar,
			ChartType.Column,
			ChartType.Line,
			ChartType.Combination,
			ChartType.Bullet,
			ChartType.VerticalBullet,
			ChartType.StackedBar,
			ChartType.StackedColumn,
			ChartType.StackedCombination,
			ChartType.HorizontalStackedCombination,
			ChartType.DualBar,
			ChartType.DualColumn,
			ChartType.DualLine,
			ChartType.DualStackedBar,
			ChartType.DualStackedColumn,
			ChartType.DualCombination,
			ChartType.DualHorizontalCombination,
			ChartType.DualStackedCombination,
			ChartType.DualHorizontalStackedCombination,
			ChartType.PercentageStackedBar,
			ChartType.PercentageStackedColumn,
			ChartType.PercentageDualStackedBar,
			ChartType.PercentageDualStackedColumn
		],
		timeChartTypes: [
			"timeseries_line",
			"timeseries_column",
			"timeseries_bubble",
			"timeseries_scatter",
			"timeseries_combination",
			"dual_timeseries_combination",
			"timeseries_bullet",
			"timeseries_stacked_column",
			"timeseries_100_stacked_column",
			"timeseries_waterfall"
		],
		oAdapteredChartTypes: {
		    "line": "timeseries_line",
		    "column": "timeseries_column",
		    "scatter": "timeseries_scatter",
		    "bubble": "timeseries_bubble",
		    "combination": "timeseries_combination",
		    "dual_combination": "dual_timeseries_combination",
		    "vertical_bullet": "timeseries_bullet",
		    "stacked_column": "timeseries_stacked_column",
		    "100_stacked_column": "timeseries_100_stacked_column",
		    "waterfall": "timeseries_waterfall"
		},
		nonSemanticPatternChartType : [
			ChartType.Combination,
			ChartType.Pie,
			ChartType.Donut,
			ChartType.Scatter,
			ChartType.Bubble,
			ChartType.Heatmap,
			ChartType.StackedBar,
			ChartType.StackedColumn,
			ChartType.StackedCombination,
			ChartType.HorizontalStackedCombination,
			ChartType.DualStackedBar,
			ChartType.DualStackedColumn,
			ChartType.DualCombination,
			ChartType.DualHorizontalCombination,
			ChartType.DualStackedCombination,
			ChartType.DualHorizontalStackedCombination,
			ChartType.PercentageStackedBar,
			ChartType.PercentageStackedColumn,
			ChartType.PercentageDualStackedBar,
			ChartType.PercentageDualStackedColumn,
			ChartType.Waterfall,
			ChartType.HorizontalWaterfall,
			"timeseries_bubble",
			"timeseries_scatter",
			"timeseries_combination",
			"dual_timeseries_combination",
			"timeseries_stacked_column",
			"timeseries_100_stacked_column",
			"timeseries_waterfall"
		]
	};
	return {
		CONFIG: _CONFIG,
		makeNotifyParentProperty: function(sPropertyName) {
			return function(oValue, bSuppressInvalidate) {
				var oOldValue = this.mProperties[sPropertyName];

				oValue = this.validateProperty(sPropertyName, oValue);

				if (jQuery.sap.equal(oOldValue, oValue)) {
					return this;
				}

				this.setProperty(sPropertyName, oValue, bSuppressInvalidate);

				if (bSuppressInvalidate) {
					return this;
				}

				var oParent = this.getParent();
				if (oParent && typeof oParent._invalidateBy === "function") {
					oParent._invalidateBy({
						source: this,
						property: sPropertyName,
						oldValue: oOldValue,
						newValue: oValue
					});
				}

				return this;
			};
		}
	};
});

}; // end of sap/chart/utils/ChartUtils.js
if ( !jQuery.sap.isDeclared('sap.chart.utils.DateFormatUtil') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */
/*
 * Parse and Format Date String depending on sap.ui.core.format.DateFormat
 */
jQuery.sap.declare('sap.chart.utils.DateFormatUtil'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.ui.core.format.DateFormat'); // unlisted dependency retained
sap.ui.define("sap/chart/utils/DateFormatUtil",[
	'sap/chart/TimeUnitType',
	'sap/ui/core/format/DateFormat'
], function(
	TimeUnitType,
	DateFormat
) {
	"use strict";

	var PATTERN_TABLE = {};
	PATTERN_TABLE[TimeUnitType.yearmonthday] =  "yyyyMMdd";
	PATTERN_TABLE[TimeUnitType.yearquarter] =  "yyyyQQQQQ";
	PATTERN_TABLE[TimeUnitType.yearmonth] =  "yyyyMM";

	function getInstance(sTimeUnitType) {
		var sPattern = PATTERN_TABLE[sTimeUnitType]; 
		if (sPattern) {
			return DateFormat.getDateInstance({pattern: sPattern});
		} else {
			return null;
		}
	}

	return {
		getInstance: getInstance
	};
});

}; // end of sap/chart/utils/DateFormatUtil.js
if ( !jQuery.sap.isDeclared('sap.chart.utils.MeasureSemantics') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.chart.utils.MeasureSemantics'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/utils/MeasureSemantics",[], function() {
	"use strict";
	
	var COLOR_PALETTE = ['sapUiChartPaletteQualitativeHue1',
						 'sapUiChartPaletteQualitativeHue2',
						 'sapUiChartPaletteQualitativeHue3',
						 'sapUiChartPaletteQualitativeHue4',
						 'sapUiChartPaletteQualitativeHue5',
						 'sapUiChartPaletteQualitativeHue6',
						 'sapUiChartPaletteQualitativeHue7',
						 'sapUiChartPaletteQualitativeHue8',
						 'sapUiChartPaletteQualitativeHue9',
						 'sapUiChartPaletteQualitativeHue10',
						 'sapUiChartPaletteQualitativeHue11'
					 ],
		DUAL_COLOR_PALETTE = [['sapUiChartPaletteSequentialHue1',
                    'sapUiChartPaletteSequentialHue1Light2',
                    'sapUiChartPaletteSequentialHue1Dark1'
                ],
                ['sapUiChartPaletteSequentialHue2',
                    'sapUiChartPaletteSequentialHue2Light2',
                    'sapUiChartPaletteSequentialHue2Dark1'
                ]],
		SINGLE_TARGET_COLOR = 'sapUiChartPaletteSequentialNeutralDark2',
		LINE_TYPE = {
			actual : 'solid',
			projected : 'dash',
			reference : 'dot'
		}, 
		PATTERN = {
			projected : 'diagonalLightStripe',
			reference : 'noFill'
		};

	function rel(oMsr) {
		var oResult = {};
		if (oMsr.getSemanticallyRelatedMeasures) {
			var oRel = oMsr.getSemanticallyRelatedMeasures();
			if (oRel) {
				if (oRel.projectedValueMeasure) {
					oResult.projected = oRel.projectedValueMeasure;
				}
				if (oRel.referenceValueMeasure) {
					oResult.reference = oRel.referenceValueMeasure;
				}
				return oResult;
			}
		}

		return oResult;
	}

	function calc(aMsrs) {
		var mComputed = aMsrs.reduce(function(mComputed, oMsr) {
			mComputed[oMsr.getName()] = {
				msr: oMsr,
				sem: (oMsr.getSemantics && oMsr.getSemantics()) || "actual",
				rel: rel(oMsr)
			};
			return mComputed;
		}, {});

		// remove mis matched (semantics, relation semantics) from each semantic
		// relation
		jQuery.each(mComputed, function(sMsr, oCfg) {
			if (oCfg.sem === "actual") {
				jQuery.each(oCfg.rel, function(sSem, sTargetMsr) {
					if (mComputed[sTargetMsr] && mComputed[sTargetMsr].sem !== sSem) {
						delete oCfg.rel[sSem];
					} else {
						jQuery.sap.log.warning("Analytical Chart", "Related measures don't match its semantic role.");
					}
				});
			}
		});

		return mComputed;
	}

	function makeTuples(aMsrs, mSems) {
		var aTuples = [], index = 0;

		jQuery.each(aMsrs.slice().sort(function(a, b) {
			var semA = mSems[a.getName()].sem,
				semB = mSems[b.getName()].sem;
			if (semA < semB) {
				return -1;
			} else if (semA > semB) {
				return 1;
			} else {
				return aMsrs.indexOf(a) - aMsrs.indexOf(b);
			}
		}), function(idx, oMsr) {
			var sName = oMsr.getName();
			if (!mSems[sName]) {
				return;
			}

			var oSemCfg = mSems[sName];
			var oTuple = {};
			var sLabel;

			oTuple[oSemCfg.sem] = sName;
			if (oMsr.getLabel) {
				sLabel = oMsr.getLabel();
				if (sLabel) {
					oTuple.labels = {};
					oTuple.labels[oSemCfg.sem] = sLabel;
				}
			}
			oTuple.index = index++;

			if (oSemCfg.sem === "actual") {
				if (oSemCfg.rel.projected && mSems[oSemCfg.rel.projected]) {
					oTuple.projected = oSemCfg.rel.projected;
					//Keep labels
					if (mSems[oSemCfg.rel.projected].msr.getLabel) {
						sLabel = mSems[oSemCfg.rel.projected].msr.getLabel();
						if (sLabel) {
							oTuple.labels = jQuery.extend(true, oTuple.labels, {
								projected: sLabel
							});
						}
					}
					delete mSems[oSemCfg.rel.projected];
				}
				if (oSemCfg.rel.reference && mSems[oSemCfg.rel.reference]) {
					oTuple.reference = oSemCfg.rel.reference;
					if (mSems[oSemCfg.rel.reference].msr.getLabel) {
						sLabel = mSems[oSemCfg.rel.reference].msr.getLabel();
						if (sLabel) {
							oTuple.labels = jQuery.extend(true, oTuple.labels, {
								reference: sLabel
							});
						}
					}
					delete mSems[oSemCfg.rel.reference];
				}
				delete mSems[sName];
			}

			aTuples.push(oTuple);

		});

		return aTuples;
	}
	
	var getSemanticVizProperties = function(chartType, semanticTuples){
		var semanticProps = {
			dataPointStyle : null,
			seriesStyle : null
		};
		if (semanticTuples) {
			var hasProjectedValueStartTime = semanticTuples.some(function(tuple){
				return tuple.projectedValueStartTime;
			}),
			hasSingleReference = (semanticTuples.filter(function(tuple){
				return tuple.reference;
			}).length === 1);

			var addDataPointStyleRules = function(rule){
				if (!semanticProps.dataPointStyle) {
					semanticProps = jQuery.extend(true, semanticProps, {
						"dataPointStyle": {
							"rules": [],
							others : null
						}
					});
				}
				semanticProps.dataPointStyle.rules.push(rule);
			};
			var addSeriesStyleRules = function(rule){
				if (!semanticProps.seriesStyle) {
					semanticProps = jQuery.extend(true, semanticProps, {
						"seriesStyle": {
							"rules": []
						}
					});
				}
				semanticProps.seriesStyle.rules.push(rule);
			};

			var getSemanticColors = function(index, valueAxisID){
				var length, colorPalette;
				if (chartType.indexOf('dual') === -1) {	
					colorPalette = COLOR_PALETTE;
					length = COLOR_PALETTE.length;
				} else {
					var axisIndex = (valueAxisID === 'valueAxis') ? 0 : 1;
					colorPalette = DUAL_COLOR_PALETTE[axisIndex];
					length = colorPalette.length;
				}
				return {
					actual : colorPalette[ index % length],
					projected : colorPalette[ index % length],
					reference : colorPalette[ index % length]
				};
			};
			
			var tuple, rule, colors, color, dataName, forecastCallbackFunc = function(timeAxis, projectedValueStartTime, semanticMsrName){
				return function(ctx){
					return (ctx.measureNames === semanticMsrName) && (new Date(ctx[timeAxis]).getTime() >= projectedValueStartTime);
				};
			},actualCallbackFunc = function(timeAxis, projectedValueStartTime, semanticMsrName){
				return function(ctx){
					return (ctx.measureNames === semanticMsrName) && (new Date(ctx[timeAxis]).getTime() < projectedValueStartTime);
				};
			}, tuplesLength = semanticTuples.length, key, sLabel;
			for (var i = 0; i < tuplesLength; i++) {
				tuple = semanticTuples[i];
				colors = getSemanticColors(tuple.index, tuple.valueAxisID);
				if (hasProjectedValueStartTime) {
					//With continues semantic pattern. Use dataPointStyle.
					if (tuple.projectedValueStartTime && tuple.timeAxis) {
						// Use dataPointStyle to draw continues semantic
						//Time Dual isn't supported. 
						dataName = {};
						sLabel = (tuple.labels && tuple.labels.actual) ? tuple.labels.actual : tuple.actual;
						dataName[tuple.semanticMsrName] = sLabel;
						addDataPointStyleRules({
							"callback" : actualCallbackFunc(tuple.timeAxis, tuple.projectedValueStartTime, tuple.semanticMsrName),
							"properties" : {
								"lineType" : LINE_TYPE.actual,
								"color" : colors.actual,
								"lineColor" : colors.actual
							},
							"displayName" : sLabel,
							"dataName" : dataName
						});
						dataName = {};
						sLabel = (tuple.labels && tuple.labels.projected) ? tuple.labels.projected : tuple.projected;
						dataName[tuple.semanticMsrName] = sLabel;
						addDataPointStyleRules({
							"callback" : forecastCallbackFunc(tuple.timeAxis, tuple.projectedValueStartTime, tuple.semanticMsrName),
							"properties" : {
								"lineType" : LINE_TYPE.projected,
								"pattern" : PATTERN.projected,
								"color" : colors.projected,
								"lineColor" : colors.projected
							},
							"displayName" : sLabel,
							"dataName" : dataName
						});
						if (tuple.reference) {
							rule = {};
							rule[tuple.reference] = '*';
							color = hasSingleReference ? SINGLE_TARGET_COLOR : colors.reference;
							sLabel = (tuple.labels && tuple.labels.reference) ? tuple.labels.reference : tuple.reference;
							addDataPointStyleRules({
								"dataContext" : [rule],
								"properties" : {
									"lineType" : LINE_TYPE.reference,
									"color" : color,
									"lineColor" : color,
									"pattern" : PATTERN.reference
								},
								"displayName" : sLabel
							});
						}
					} else {
						//Series without semantic relation in continue series chart.
						//Draw its normal style accroding with UX design.
						for (key in tuple) {
							if (tuple.hasOwnProperty(key) && key !== 'valueAxisID' && key !== 'index') {
								rule = {};
								rule[tuple[key]] = '*';
								sLabel = (tuple.labels && tuple.labels[key]) ? tuple.labels[key] : tuple[key];

								color = (hasSingleReference && key === 'reference') ? SINGLE_TARGET_COLOR : colors[key];
								
								addDataPointStyleRules({
									"dataContext" : [rule],
									"properties" : {
										"lineType" : LINE_TYPE[key],
										"color" : color,
										"lineColor" : color,
										"pattern" : PATTERN[key]
									},
									"displayName" : sLabel
								});
							}
						}
					}
				} else if (chartType && chartType.indexOf('bullet') === -1) {
					for (key in tuple) {
						if (tuple.hasOwnProperty(key) && key !== 'valueAxisID' && key !== 'index') {
							rule = {};
							rule[tuple[key]] = '*';

							color = ( hasSingleReference && key === 'reference' ) ? SINGLE_TARGET_COLOR : colors[key];

							addSeriesStyleRules({
								"dataContext" : [rule],
								"properties" : {
									"dataPoint": {
										"color" : color,
										"pattern" : PATTERN[key]
									}, 
									"line":{
										"type": LINE_TYPE[key],
										"color" : color
									}
								},
								"displayName" : tuple[key]
							});
						}
					}
				}			
			}
		}
		return {
			"plotArea" : semanticProps
		};
	};

	return {
		getTuples: function(aMsrs) {
			return makeTuples(aMsrs, calc(aMsrs));
		},
		getSemanticVizProperties : getSemanticVizProperties
	};
});

}; // end of sap/chart/utils/MeasureSemantics.js
if ( !jQuery.sap.isDeclared('sap.chart.utils.SelectionAPIUtils') ) {
/*
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */
jQuery.sap.declare('sap.chart.utils.SelectionAPIUtils'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/utils/SelectionAPIUtils",[
    
],function(

) {
    "use strict";

    function makeLookUp(aKeys) {
        return aKeys.reduce(function(mLookUp, sKey) {
            mLookUp[sKey] = true;
            return mLookUp;
        }, {});
    }
    function toVizCtx(aVisibleMeasures, aVisibleDimensions) {
        var mVisibleMsrs = makeLookUp(aVisibleMeasures);

        function dimWrapper(oContextObj) {
            return aVisibleDimensions.reduce(function(oPartialDataCtx, sDim) {
                if (oContextObj.hasOwnProperty(sDim)) {
                    oPartialDataCtx[sDim] = oContextObj[sDim];
                }
                return oPartialDataCtx;
            }, {});
        }

        return function(aRequestedMeasures, oContextObj) {
            return aRequestedMeasures.filter(function(sMsr) {
                return mVisibleMsrs[sMsr];
            }).map(function(sMsr) {
                var oDataCtx = dimWrapper(oContextObj);
                oDataCtx[sMsr] = "*";
                return {data: oDataCtx};
            });
        };
    }

    function toVizCSCtx(oCtx) {
        var oVizCtx = {data:{}},
            oMsrVal = oCtx.measures,
            oDimVal = oCtx.dimensions;

        if (oMsrVal) {
            oVizCtx.data.measureNames = (oMsrVal instanceof Array) ? {"in": oMsrVal} : oMsrVal;
        }

        jQuery.each(oDimVal || {}, function(k, v) {
            oVizCtx.data[k] = (v instanceof Array) ? {"in": v} : v;
        });

        return oVizCtx;
    }

    function fromVizCSCtx(oVizCtx) {
        var oData = oVizCtx.data;
        return Object.keys(oData).reduce(function(obj, k) {
            var v = oData[k];
            if (v.in && v.in instanceof Array) {
                v = v.in;
            }
            if (k === "measureNames") {
                obj.measures = v;
            } else if (!obj.dimensions) {
                obj.dimensions = {};
                obj.dimensions[k] = v;
            } else {
                obj.dimensions[k] = v;
            }
            return obj;
        }, {});
    }

    function buildSelectionVizCtx(aVisibleMeasures, aVisibleDimensions, oBinding, aContexts) {
        var converter = toVizCtx(aVisibleMeasures, aVisibleDimensions);
        return aContexts.reduce(function(aData, oCtx) {
            var aCtxs = oBinding.getContexts(oCtx.index, 1);
            if (aCtxs.length > 0) {
                aData = aData.concat(converter(oCtx.measures, aCtxs[0].getObject()));
            }
            return aData;
        }, []);
    }

    function filterVisibleMsr(data, mVisibleMsrs){
        return Object.keys(data).filter(function(sMsr){
            return (mVisibleMsrs.indexOf(sMsr) !== -1);
        });
    }

    function filterSemMsr(oSemanticTuples, mVisibleMsrs, mDataPoint){
        //Filter continues meausre accroding with projectedValueStartTime
        if (oSemanticTuples) {
            var sInvisibleSemMsr, tuple;
            for (tuple in oSemanticTuples) {
                if (oSemanticTuples.hasOwnProperty(tuple) && mDataPoint.data[tuple]) {
                    var semanticRule = oSemanticTuples[tuple];
                    sInvisibleSemMsr = (mDataPoint.data[semanticRule.timeAxis] < semanticRule.projectedValueStartTime) ? semanticRule.projected : semanticRule.actual;
                }
            }
            if (sInvisibleSemMsr) {
                //Hit continues series data point. Filter inVisible measure info.
                mDataPoint.measures = mDataPoint.measures.filter(function(sMsr){
                    return (sMsr !== sInvisibleSemMsr);
                });
                if (mDataPoint.dataName) {
                    mDataPoint.dataName = Object.keys(mDataPoint.dataName).reduce(function(dataName, key, i){
                        if (mVisibleMsrs.indexOf(key) !== -1){
                            dataName[key] = mDataPoint.dataName[key];
                        }
                        return dataName;
                    }, {});
                    if (jQuery.isEmptyObject(mDataPoint.dataName)) {
                        delete mDataPoint.dataName;
                    }
                }
            } else {
                var unboundMsrs = [];
                for (var key in oSemanticTuples) {
                    if (oSemanticTuples.hasOwnProperty(key)) {
                        tuple = oSemanticTuples[key];
                        unboundMsrs.push(tuple.actual);
                        unboundMsrs.push(tuple.projected);
                    }
                }
                //Hit normal series in a continues chart. Filter unbound measures.
                mDataPoint.measures = mDataPoint.measures.filter(function(sMsr){
                    return unboundMsrs.indexOf(sMsr) === -1;
                });
            }
        }
    }

    return {
        makeLookUp: makeLookUp,
        toVizCtx: toVizCtx,
        toVizCSCtx: toVizCSCtx,
        fromVizCSCtx: fromVizCSCtx,
        buildSelectionVizCtx: buildSelectionVizCtx,
        filterVisibleMsr : filterVisibleMsr,
        filterSemMsr: filterSemMsr,
        match: function(oRef, oVal, aMeasures) {
            return Object.keys(oRef).every(function(k) {
                if (aMeasures.indexOf(k) !== -1) {
                    return oVal.hasOwnProperty(k);
                } else {
                    return oRef[k] === oVal[k];
                }
            });
        }
    };
});

}; // end of sap/chart/utils/SelectionAPIUtils.js
if ( !jQuery.sap.isDeclared('sap.chart.utils.SeriesColorTracker') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */
/*
 * Keep track of series colors on different *pages*.
 */
jQuery.sap.declare('sap.chart.utils.SeriesColorTracker'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/utils/SeriesColorTracker",[], function() {
	"use strict";

	var _COLOR_FEEDS = {
			color: true,
			color2: true
	};
	
	function SeriesColorTracker() {
		this._mSeriesColor = {};
	}
	
	/**
	 * Convert CVOM data context into a string key
	 * @param {any} oCtx a single aCtx CVOM data context, which is an array of string/null/undefined/number/object
	 * @returns {string} string representation of the data context
	 */
	function seriesKey(oCtx) {
		var sType = jQuery.type(oCtx);
		switch (sType) {
		case "string":
			return '"' + oCtx + '"';
		case "null":
		case "undefined":
			return sType;
		case "array":
			return "[" + oCtx.map(seriesKey).join(",") + "]";
		case "object":
			return "{" + Object.keys(oCtx).map(function(sProp) {
				return '"' + sProp + '":' + seriesKey(oCtx[sProp]);
			}).join(",") + "}";
		case "number":
		case "boolean":
			return String(oCtx);
		default:
			return sType + "<" + String(oCtx) + ">";			
		}
	}
	
	/**
	 * Add CVOM runtime scales to record if not tracked already
	 * @param {object[]} aRuntimeScales CVOM runtime scales
	 */
	SeriesColorTracker.prototype.add = function(aRuntimeScales) {
		var mAllSeriesColor = this._mSeriesColor,
			mSeriesColor;
		aRuntimeScales.forEach(function(oRTScale) {
			var sFeed = oRTScale.feed;
			if (!_COLOR_FEEDS[sFeed]) {
				return;
			}
			
			mSeriesColor = mAllSeriesColor[sFeed];
			if (!mSeriesColor) {
				mSeriesColor = {};
				mAllSeriesColor[sFeed] = mSeriesColor;
			}
			
			oRTScale.results.forEach(function(oResult) {
				var sKey = seriesKey(oResult.dataContext);
				if (!mSeriesColor[sKey]) {
					mSeriesColor[sKey] = oResult;
				}
			});
		});
	};
	
	/**
	 * Return currently tracked series colors in CVOM runtime scales format
	 * @returns {object} series colors
	 */
	SeriesColorTracker.prototype.get = function() {
		var aFeeds = Object.keys(this._mSeriesColor);
		var mSeriesColor = this._mSeriesColor;
		return aFeeds.map(function(sFeedId) {
			var aKeys = Object.keys(mSeriesColor[sFeedId]);			
			return aKeys.length === 0 ? null : {
				results: aKeys.map(function(sKey) {
					return mSeriesColor[sFeedId][sKey];
				}),
				feed: sFeedId
			};	
		});		
	};
	
	SeriesColorTracker.prototype.clear = function() {
		this._mSeriesColor = {};
	};
	
	return SeriesColorTracker;
});
}; // end of sap/chart/utils/SeriesColorTracker.js
if ( !jQuery.sap.isDeclared('sap.chart.data.Dimension') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.chart.data.Dimension'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained
sap.ui.define("sap/chart/data/Dimension",[
	"sap/ui/core/Element",
	"sap/chart/utils/ChartUtils"
], function(
	Element,
	ChartUtils
) {
	"use strict";
	var _SUPPORTED_ROLE = {category:true,category2:true,series:true};

	/**
	 * Constructor for a new ui5/data/Dimension.
	 *
	 * @param {string} [sId] id for the new control, generated automatically if no id is given 
	 * @param {object} [mSettings] initial settings for the new control
	 *
	 * @class
	 * Definition of a single dimension in a chart
	 * @extends sap.ui.core.Element
	 *
	 * @constructor
	 * @public
	 * @since 1.32.0
	 * @name sap.chart.data.Dimension
	 */
	var Dimension = Element.extend("sap.chart.data.Dimension", {
		metadata : {
			library : "sap.chart",
			properties : {
				/**
				 * Property in the "data" model holding the (always unique) Dimension key.
				 */
				name : {type : "string"},
				/**
				 * Label for the Dimension, either as a string literal or by a pointer using the binding syntax to some property containing the label.
				 *
				 * NOTE: This property was bound internally if automatically created via metadata of oData service and please call "unbindProperty" before setting.
				 */
				label: {type: "string"},
				/**
				 * Function returning a formatted text for a Dimension key value that will be used for axis labelling. If specified, this property takes precedence over the "textProperty" property of the Dimension.
				 * Dimension key value and the corresponding text will be passed to the supplied function as parameters.
				 */
				textFormatter: {type: "function"},
				/**
				 * Text for a Dimension key value, typically by a pointer using the binding syntax to some property containing the text.
				 *
				 * NOTE: This property was bound internally if automatically created via metadata of oData service and please call "unbindProperty" before setting.
				 */
				textProperty: {type: "string"},
				/**
				 * Whether a text is displayed. If the "textProperty" property has not been specified, it will be derived from the metadata.
				 */
				displayText: {type: "boolean", defaultValue: true},
				/**
				 * How the Dimension will influence the chart layout. Possible values are "category" or "series".
				 * The default is "category".
				 * NOTE: Has no effect if the Dimension is used as inResultDimensions by Chart
				 */
				role: {type: "string", defaultValue: "category"}
			}
		}
	});
	
	Dimension.prototype.setLabel = ChartUtils.makeNotifyParentProperty("label");	
	Dimension.prototype.setTextFormatter = ChartUtils.makeNotifyParentProperty("textFormatter");	
	var textPropertySetter = ChartUtils.makeNotifyParentProperty("textProperty");
	Dimension.prototype.setTextProperty = function(sValue, bSuppressInvalidate) {
		return textPropertySetter.apply(this, arguments);
	};
	Dimension.prototype.setDisplayText = ChartUtils.makeNotifyParentProperty("displayText");
	var roleSetter = ChartUtils.makeNotifyParentProperty("role");
	Dimension.prototype.setRole = function(sValue, bSuppressInvalidate) {
		if (!_SUPPORTED_ROLE[sValue]) {
			jQuery.error("Invalide Dimension role: " + sValue);
		}
		return roleSetter.apply(this, arguments);
	};
	Dimension.prototype._getFixedRole = function() {
		return this._sFixedRole || this.getRole();
	};
	return Dimension;
});

}; // end of sap/chart/data/Dimension.js
if ( !jQuery.sap.isDeclared('sap.chart.data.TimeDimension') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.chart.data.TimeDimension'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/data/TimeDimension",[
	"sap/chart/data/Dimension",
	"sap/chart/utils/ChartUtils"
], function(
	Dimension,
	ChartUtils
) {
	"use strict";

	/**
	 * Constructor for a new ui5/data/TimeDimension.
	 *
	 * @param {string} [sId] id for the new control, generated automatically if no id is given 
	 * @param {object} [mSettings] initial settings for the new control
	 *
	 * @class
	 * Definition of a single time dimension in a chart
	 * @extends sap.chart.data.Dimension
	 *
	 * @constructor
	 * @public
	 * @since 1.38.0
	 * @name sap.chart.data.TimeDimension
	 */
	var TimeDimension = Dimension.extend("sap.chart.data.TimeDimension", {
		metadata : {
			library : "sap.chart",
			properties : {
				/**
				 * Detailed unit infomation of TimeDimension. Please refer to {@link sap.chart.TimeUnitType TimeUnitType}.
				 */
				timeUnit : {type : "sap.chart.TimeUnitType"},
				/**
				 * Detailed fiscalYearPeriodCount of TimeDimension. It contains period numbers of fiscal years, like
				 * <pre>
				 * {
				 *	 default: 12,
				 *	 deviations: {
				 *	 	 "2012": 10,
				 *	 	 "2013": 16
				 *	 }
				 * }
				 * </pre>
				 */
				fiscalYearPeriodCount : {type : "object"},
				/**
				 * A time value (aligned with 'timeUnit') to indicate the start point of projected values.
				 */
				projectedValueStartTime : { type: "any"}
			}
		}
	});
	
	TimeDimension.prototype.setTimeUnit = ChartUtils.makeNotifyParentProperty("timeUnit");
	TimeDimension.prototype.setFiscalYearPeriodCount = ChartUtils.makeNotifyParentProperty("fiscalYearPeriodCount");
	TimeDimension.prototype.setProjectedValueStartTime = ChartUtils.makeNotifyParentProperty("projectedValueStartTime");

	return TimeDimension;
});

}; // end of sap/chart/data/TimeDimension.js
if ( !jQuery.sap.isDeclared('sap.chart.utils.ChartTypeAdapterUtils') ) {
/*
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */
jQuery.sap.declare('sap.chart.utils.ChartTypeAdapterUtils'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/utils/ChartTypeAdapterUtils",[
    'sap/chart/utils/ChartUtils'
],function(
    ChartUtils
) {
    "use strict";

    var ChartTypeAdapterUtils = {};

    function timeSeriesAdaptHandler(sChartType, aDimensions) {
        var bHasTimeDimension = aDimensions.some(function(oDim) {
            return oDim instanceof sap.chart.data.TimeDimension;
        });
        if (bHasTimeDimension) {
            return ChartUtils.CONFIG.oAdapteredChartTypes[sChartType];
        } else {
            return sChartType;
        }
    }

    ChartTypeAdapterUtils.adaptChartType = function(sChartType, aDimensions) {
        if (ChartUtils.CONFIG.oAdapteredChartTypes[sChartType]) {
            return timeSeriesAdaptHandler(sChartType, aDimensions);
        } else {
            return sChartType;
        }
    };

    return ChartTypeAdapterUtils;
});

}; // end of sap/chart/utils/ChartTypeAdapterUtils.js
if ( !jQuery.sap.isDeclared('sap.chart.utils.RoleMapper') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.chart.utils.RoleMapper'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/utils/RoleMapper",[
	'sap/chart/data/TimeDimension',
	'sap/chart/utils/MeasureSemantics',
	'sap/chart/utils/ChartUtils',
	'sap/chart/utils/DateFormatUtil'
], function(
	TimeDimension,
	MeasureSemantics,
	ChartUtils,
	DateFormatUtil
) {
	"use strict";

	function RoleMapper(sFeedingId) {
		this._bTimeFed = false;
	}

	RoleMapper.prototype.toFeedingId = function(oDim) {
		if (oDim instanceof TimeDimension && !this._bTimeFed) {
			this._bTimeFed = true;
			return "timeAxis";
		} else {
			return "@context";
		}
	};

	function trimRight(aArray) {
		while (aArray.length && !aArray[aArray.length - 1]) {
			aArray.pop();
		}
		return aArray;
	}

	function isTimeChart(chartType) {
		return ChartUtils.CONFIG.timeChartTypes.indexOf(chartType) > -1;
	}

	function isDualChart(chartType){
		return chartType.indexOf('dual') > -1;
	}

	RoleMapper.semantics = {
		semanticBulletMsrs: function(oMsrFeeds, isTimeChart) {
			var aMsrs = oMsrFeeds["@semanticBulletMsrs"];
			var mMsrs = aMsrs.reduce(function(mMsrs, oMsr) {
				mMsrs[oMsr.getName()] = oMsr;
				return mMsrs;
			}, {});
			var aSemanticTuples = MeasureSemantics.getTuples(aMsrs);

			var oSemFeeds = {
				actualValues: [],
				additionalValues: [],
				targetValues: []
			};

			jQuery.each(aSemanticTuples, function(idx, oTuple) {
				oSemFeeds.actualValues.push(oTuple.actual ? mMsrs[oTuple.actual] : null);
				oSemFeeds.additionalValues.push(oTuple.projected ? mMsrs[oTuple.projected] : null);
				oSemFeeds.targetValues.push(oTuple.reference ? mMsrs[oTuple.reference] : null);
			});

			Object.keys(oSemFeeds).forEach(function(key) {
				oSemFeeds[key] = trimRight(oSemFeeds[key]);
			});

			delete oMsrFeeds["@semanticBulletMsrs"];

			jQuery.extend(oMsrFeeds, oSemFeeds);
		},
		semanticPatternMsrs : function(oFeeds, chartType){
			var aAllSemanticTuples = [], aAllSemanticContext = [];

			Object.keys(oFeeds.msrs).forEach(function(key){
				var aSemanticContext = [];
				var aMsrs = oFeeds.msrs[key];
				var mMsrs = aMsrs.reduce(function(mMsrs, oMsr) {
					mMsrs[oMsr.getName()] = oMsr;
					return mMsrs;
				}, {});
				var aSemanticTuples = MeasureSemantics.getTuples(aMsrs);
				var hasSemanticRules = aSemanticTuples.filter(function(tuple){
						return tuple.actual && !tuple.projected && !tuple.reference;
					}).length !== aMsrs.length;
				if (oFeeds.dims.color && oFeeds.dims.color.length > 0) {
					jQuery.sap.log.warning("If Chart has series dimensions, semantic pattern rule doesn't work.");
				} else if (hasSemanticRules) {
					if (chartType && isDualChart(chartType)) {
						aSemanticTuples.forEach(function(value){
							value.valueAxisID = key;
						});
					}
					aAllSemanticTuples = aAllSemanticTuples.concat(aSemanticTuples);
					
					if (isTimeChart(chartType)) {
						//No color feeds and time axis's max size is 1
						if (oFeeds.dims.timeAxis && oFeeds.dims.timeAxis.length === 1) {
							var timeAxis = oFeeds.dims.timeAxis[0];
							var tuple;
							
							var projectedValueStartTime = timeAxis.getProjectedValueStartTime();
							if (projectedValueStartTime) {
								//Format startTime value according with timeUnit setting	
								var startTime, oDateInstance = DateFormatUtil.getInstance(timeAxis.getTimeUnit());
								if (oDateInstance) {
									if (oDateInstance.parse(projectedValueStartTime)) {
										startTime = oDateInstance.parse(projectedValueStartTime).getTime();
									}
								} else {
									startTime = new Date(projectedValueStartTime).getTime();
								}
								if (startTime) {
									if (chartType.indexOf('bullet') === -1) {
										for (var i = 0; i < aSemanticTuples.length; i++) {
											tuple = aSemanticTuples[i];
											if (tuple.actual && tuple.projected) {
												tuple.timeAxis = oFeeds.dims.timeAxis[0].getName();
												tuple.projectedValueStartTime = startTime;
												tuple.semanticMsrName = tuple.actual + "-" + tuple.projected;
												aSemanticContext.push(tuple.actual);
												aSemanticContext.push(tuple.projected);
												aMsrs.push(mMsrs[tuple.actual].clone().setName(tuple.semanticMsrName));
											}
										}
									} 
									oFeeds.msrs[key] = aMsrs.filter(function(oMsr){
										return aSemanticContext.indexOf(oMsr.getName()) === -1;
									});
									
									aAllSemanticContext = aAllSemanticContext.concat(aMsrs.filter(function(oMsr){
										return aSemanticContext.indexOf(oMsr.getName()) > -1;
									}));
								}
							}
						}
					}
					var aSemanticTuplesList = [];
					var aMsrOrder = ['actual', 'projected', 'semanticMsrName', 'reference'];

					aSemanticTuples.forEach(function(elem){
						for (var i = 0; i < aMsrOrder.length; i++) {
							if (elem[aMsrOrder[i]]) {
								aSemanticTuplesList.push(elem[aMsrOrder[i]]);	
							}
						}
					});
					oFeeds.msrs[key].sort(function(a, b){
					    return aSemanticTuplesList.indexOf(a.getName()) - aSemanticTuplesList.indexOf(b.getName());
				    });
				}
			});
			
			return {
				semanticTuples : aAllSemanticTuples,
				contexts: aAllSemanticContext
			};
		}
	};

	return RoleMapper;
});

}; // end of sap/chart/utils/RoleMapper.js
if ( !jQuery.sap.isDeclared('sap.chart.utils.RoleFitter') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.chart.utils.RoleFitter'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.viz.ui5.data.DimensionDefinition'); // unlisted dependency retained
jQuery.sap.require('sap.viz.ui5.data.MeasureDefinition'); // unlisted dependency retained
jQuery.sap.require('sap.viz.ui5.controls.common.feeds.FeedItem'); // unlisted dependency retained
jQuery.sap.require('sap.viz.ui5.controls.common.feeds.AnalysisObject'); // unlisted dependency retained
sap.ui.define("sap/chart/utils/RoleFitter",[
	'sap/viz/ui5/data/DimensionDefinition',
	'sap/viz/ui5/data/MeasureDefinition',
	'sap/viz/ui5/controls/common/feeds/FeedItem',
	'sap/viz/ui5/controls/common/feeds/AnalysisObject',
	'sap/chart/TimeUnitType',
	'sap/chart/utils/DateFormatUtil',
	'sap/chart/utils/ChartUtils',
	'sap/chart/utils/RoleMapper'
], function(
	DimensionDefinition,
	MeasureDefinition,
	FeedItem,
	AnalysisObject,
	TimeUnitType,
	DateFormatUtil,
	ChartUtils,
	RoleMapper
) {
	"use strict";

	var suggestFeeds = function() {
		return sap.viz.vizservices.BVRService.suggestFeeds.apply(null, arguments);
	};
	var validateFeeds = function(chartType, feedItems) {
		var oResults = sap.viz.vizservices.FeedService.validate(chartType, feedItems);
		if (!oResults.valid) {
			var bindings = oResults.results ? oResults.results.bindings : null;
			if (bindings && Object.keys(bindings).every(function(item) {
					return bindings[item].allowMND && (!bindings[item].missing || bindings[item].missing === 1) && !bindings[item].incorrect;
				})) {
				// previously we suggest mnd to check feeding, but BVR will remove invalid feeding items in some case
				// currently for case whose feeding only miss mnd, we let it pass directly
				return {
					valid: true
				};
			}
		}
		return oResults;
	};
	
	var _mRoleFeedMapping = [
		{"types":"*","toViz":{"category|category2":"categoryAxis","series":"color","axis1|axis2|axis3|axis4":"valueAxis"}},
		{"types":"column|bar|stacked_bar|stacked_column|line|combination|100_stacked_bar|100_stacked_column|stacked_combination|horizontal_stacked_combination","toViz":{}},
		{"types":"scatter|bubble|time_bubble|timeseries_scatter|timeseries_bubble","toViz":{"category|category2":"@context","axis1":"valueAxis","axis2":"valueAxis2"}},
		{"types":"bubble|time_bubble","toViz":{"axis3":"bubbleWidth"}},
		{"types":"pie|donut","toViz":{"category|series|category2":"color","axis1|axis2|axis3|axis4":"size"}},
		{"types":"bullet|vertical_bullet","toViz":{"axis1|axis2|axis3|axis4": "@semanticBulletMsrs"}},
		{"types":"dual_combination|dual_horizontal_combination|dual_stacked_bar|100_dual_stacked_bar|dual_stacked_column|100_dual_stacked_column|dual_bar|dual_column|dual_line|dual_stacked_combination|dual_horizontal_stacked_combination","toViz":{"axis1":"valueAxis","axis2|axis3|axis4":"valueAxis2"}},
		{"types":"timeseries_line|timeseries_column|timeseries_combination|timeseries_stacked_column|timeseries_100_stacked_column","toViz":{"category":"timeAxis"}},
		{"types":"timeseries_scatter","toViz":{"category":RoleMapper,"axis2|axis3":false}},
		{"types":"timeseries_bubble","toViz":{"category":RoleMapper,"axis2":false,"axis3":"bubbleWidth"}},
		{"types":"dual_timeseries_combination","toViz":{"category":"timeAxis", "axis1":"valueAxis", "axis2|axis3|axis4":"valueAxis2"}},
		{"types":"heatmap","toViz":{"category":"categoryAxis","category2|series":"categoryAxis2","axis1|axis2|axis3|axis4":"color"}},
		{"types":"waterfall|horizontal_waterfall","toViz":{"series":"waterfallType"}},
		{"types":"timeseries_bullet","toViz":{"category|series":"timeAxis", "axis1|axis2|axis3|axis4": "@semanticBulletMsrs"}},
		{"types":"timeseries_waterfall","toViz":{"category|series":"timeAxis"}}
	].reduce(function(m, row) {
		var cfg = Object.keys(row.toViz).reduce(function(cfg, roles) {
			roles.split("|").forEach(function(r) {
				cfg[r] = row.toViz[roles];
				return cfg;
			});
			return cfg;
		}, {});
		row.types.split("|").forEach(function(type) {
			if (!m.hasOwnProperty(type)) {
				m[type] = [];
			}
			m[type].push(cfg);
		});
		return m;
	}, {});

	var _mRoleLookUp = Object.keys(_mRoleFeedMapping).reduce(function(m, type) {
		if (type !== "*") {
			m[type] = jQuery.extend.apply(null, [true, {}].concat(_mRoleFeedMapping["*"].concat(_mRoleFeedMapping[type])));
		}
		return m;
	}, {});

	function _groupBy(aList, oKey, fnVal) {
		var keyFn = (typeof oKey === "function") ? oKey : function(obj) {
			return obj[oKey];
		};
		return aList.reduce(function(oGrouped, oElement) {
			var key = keyFn(oElement),
				val = (typeof fnVal === "function") ? fnVal(oElement) : oElement;
			if (key && !oGrouped[key]) {
				oGrouped[key] = [val];
			} else if (key) {
				oGrouped[key].push(val);
			}
			return oGrouped;
		}, {});
	}

	function _calibrate(mDef, aDimsOrMsrs) {
		var oGrouped = {}, mRoleMapping;
		aDimsOrMsrs.forEach(function(v){
			var role = v.getRole();
			if (mDef.hasOwnProperty(role)) {
				var key = mDef[role];
				if (key) {
					if (typeof key === "function") {
						if (!mRoleMapping) {
							mRoleMapping = new key();
						}
						key = mRoleMapping.toFeedingId(v);
					}
					if (!oGrouped[key]) {
						oGrouped[key] = [];
					}
					oGrouped[key].push(v);
				}
			}
		});
		return oGrouped;
	}

	var LwFeed = {
		from: FeedItem.fromLightWeightFmt,
		build: function(oObject) {
			var aLwFeeds = [];
			jQuery.each(oObject.dims, function(k, v) {
				aLwFeeds.push({
					id: k,
					type: "Dimension",
					values: v.map(analysisObjectFmt("Dimension"))
				});
			});
			jQuery.each(oObject.msrs, function(k, v) {
				aLwFeeds.push({
					id: k,
					type: "Measure",
					values: v.map(analysisObjectFmt("Measure"))
				});
			});
			return aLwFeeds;
		}
	};

	function analysisObjectFmt(sType) {
		return function(oDorM) {
			var sId = oDorM.getName();
			if (sId === "MND") {
				// feeding MND is special, its type is not Dimension
				return {
					id: "MND",
					type: "MND"
				};
			}
			var analysisObj = {
				id: sId,
				name: sId,
				type: sType
			};

			if (oDorM instanceof sap.chart.data.TimeDimension) {
				analysisObj.dataType = "Date";
			}

			return analysisObj;
		};
	}

	function wrapDimension(oDimension, isTimeChart) {
		var sName = oDimension.getName(),
			sLabel = oDimension.getLabel(),
			sText = oDimension.getTextProperty(),
			fFormatter = oDimension.getTextFormatter(),
			bDisplyaText = oDimension.getDisplayText();
		var oDimConfig = {
			identity: sName,
			name: sLabel || sName,
			value: "{" + sName + "}"
		};

		if (typeof fFormatter === "function") {
			oDimConfig.displayValue = {
				formatter: fFormatter,
				parts: [{
					path: sName,
					type: new sap.ui.model.type.String()
				}]
			};
			if (sText) {
				oDimConfig.displayValue.parts.push({
					path: sText,
					type: new sap.ui.model.type.String()
				});
			}
		} else if (bDisplyaText && sText) {
			oDimConfig.displayValue = "{" + sText + "}";
		}

		var oDimensionDefinition = new DimensionDefinition(oDimConfig);
		if (isTimeChart && oDimension instanceof sap.chart.data.TimeDimension) {
			var oDateInstance = DateFormatUtil.getInstance(oDimension.getTimeUnit());
			if (oDateInstance) {
				var fnParser = oDateInstance.parse.bind(oDateInstance);
				oDimensionDefinition.getBindingInfo("value").formatter = function(oValue) {
					return fnParser(oValue);
				};				
			}

			oDimensionDefinition.setDataType("Date");
			oDimensionDefinition._setTimeUnit(oDimension.getTimeUnit());
		}
		return oDimensionDefinition;
	}

	function wrapMeasure(oMeasure) {
		var sName = oMeasure.getName();

		var oMsrDef = new MeasureDefinition({
			identity: sName,
			name: oMeasure.getLabel() || sName,
			value: "{" + sName + "}"
		});
		oMsrDef._setUnitBinding(oMeasure.getUnitBinding());
		return oMsrDef;
	}

	function dimOrder(sChartType, aFeeds) {
		var oMetadata = sap.viz.api.metadata.Viz.get("info/" + sChartType),
			mBindings = _groupBy(oMetadata.bindings, "role"),
			mFeeds = _groupBy(aFeeds, "id"),
			aCatFeeds = mBindings["layout.category"] || [],
			aSerFeeds = mBindings["mark.color"] || [];

		if (aCatFeeds.length === 0) {
			return [];
		} else {
			var aOrder = [];

			jQuery.each(aCatFeeds.concat(aSerFeeds), function(id, oBnd) {
				var oFeed = mFeeds[oBnd.id];
				if (oFeed && oFeed.length > 0) {
					jQuery.each(oFeed[0].values, function(iid, oVal) {
						aOrder.push(oVal.id);
					});
				}
			});

			return aOrder;
		}
	}

	function isTimeChart(chartType) {
		return ChartUtils.CONFIG.timeChartTypes.indexOf(chartType) > -1;
	}

	function fitBasic(sChartType, aDimensions, aMeasures, bEnableSemanticPattern) {
		var mRoleToFeed = _mRoleLookUp[sChartType];
		var oMapped = {
			dims: _calibrate(mRoleToFeed, aDimensions),
			msrs: _calibrate(mRoleToFeed, aMeasures)
		};
		var aContexts = null, oSemanticsMsrsRules = null;

		if (oMapped.dims["@context"]) {
			aContexts = oMapped.dims["@context"];
			delete oMapped.dims["@context"];
		}
		
		if (oMapped.msrs["@semanticBulletMsrs"]) {
			RoleMapper.semantics.semanticBulletMsrs(oMapped.msrs, isTimeChart(sChartType));
		}
		
		if (ChartUtils.CONFIG.nonSemanticPatternChartType.indexOf(sChartType) === -1 && bEnableSemanticPattern) {
			oSemanticsMsrsRules = RoleMapper.semantics.semanticPatternMsrs(oMapped, sChartType);
			aContexts = (aContexts || []).concat(oSemanticsMsrsRules.contexts);	
		} else {
			if (bEnableSemanticPattern) {
				jQuery.sap.log.warning('Analytical Chart', sChartType + " doesn't support semantic pattern feature.");	
			} else {
				jQuery.sap.log.warning('DataPointStyle or seriesStyle have been set.');
			}		
		}
		
		var aFeeds = LwFeed.build(oMapped);
		aFeeds.contexts = aContexts;
		if (oSemanticsMsrsRules) {
			aFeeds.semanticTuples = oSemanticsMsrsRules.semanticTuples;	
		}

		return aFeeds;
	}

	var INRESULT_SUPPORT = [{
		chartTypes: "bar,column,line,combination,heatmap,bullet,vertical_bullet,stacked_bar,stacked_column,stacked_combination,horizontal_stacked_combination,dual_bar,dual_column,dual_line,dual_stacked_bar,dual_stacked_column,dual_combination,dual_horizontal_combination,dual_stacked_combination,dual_horizontal_stacked_combination,100_stacked_bar,100_stacked_column,100_dual_stacked_bar,100_dual_stacked_column,waterfall,horizontal_waterfall".split(","),
		feed: "categoryAxis"
	}, {
		chartTypes: "donut,pie,scatter,bubble".split(","),
		feed: "color"
	}];
	
	function appendInResults(sChartType, aFeeds, aInResults) {
		var i, sFeedId;
		for (i = 0; i < INRESULT_SUPPORT.length; i++) {
			if (INRESULT_SUPPORT[i].chartTypes.indexOf(sChartType) !== -1) {
				sFeedId = INRESULT_SUPPORT[i].feed;
				break;
			}
		}

		var bHasAppendableFeed = aFeeds.some(function(oFeed) {
			return oFeed.id === sFeedId;
		});
		// no visible dimension, reconstruct feedItems with MND
		if (!bHasAppendableFeed) {
			var aFeedsWithMND = suggestFeeds("info/" + sChartType, aFeeds, [{id:"MND",type:"MND"}]).feedItems;
			aFeeds.splice(0, aFeeds.length);
			aFeedsWithMND.forEach(function(oFeed) {
				if (oFeed.values.length > 0) {
					aFeeds.push(oFeed);
				}
			});
			aFeeds = enforceFeedType(sChartType, aFeeds);
		}
		for (i = 0; i < aFeeds.length; i++) {
			if (aFeeds[i].id === sFeedId && aFeeds[i].type === "Dimension") {
				aFeeds[i].values = aFeeds[i].values.concat(aInResults.map(function(oDim) {
					return {id: oDim.getName(), name: oDim.getName(), type: "Dimension", inResult: true};
				}));
			}
		}

		return validateFeeds("info/" + sChartType, aFeeds);
	}

	function resetFixedRole(aDorMs) {
		aDorMs.forEach(function(oDorM) {
			oDorM._sFixedRole = oDorM.getRole();
		});
	}

	function fixRole(sChartType, aFeeds, aDorMs) {
		aFeeds.forEach(function(oFeed) {
			oFeed.values.forEach(function(oFeedItem) {
				var oDorM = aDorMs.filter(function(oDorM) {
					return oDorM.getName() === oFeedItem.id;
				})[0];
				if (oDorM) {
					jQuery.each(_mRoleLookUp[sChartType], function(key, val) {
						if (val === oFeed.id) {
							oDorM._sFixedRole = key;
							return false;
						}
					});
				}
			});
		});
	}

	function fit(sChartType, aDimensions, aMeasures, aInResults, bEnableSemanticPattern) {
		var aFeeds = fitBasic(sChartType, aDimensions, aMeasures, bEnableSemanticPattern),
			aContexts = aFeeds.contexts,
			semanticTuples = aFeeds.semanticTuples,
			continueSemanticTuples = [];

		if (semanticTuples) {
			continueSemanticTuples = semanticTuples.filter(function(tuple){
				return tuple.projectedValueStartTime;
			});
		}
		
		var oValidation = validateFeeds("info/" + sChartType, aFeeds);

		var aDorMs = aDimensions.concat(aMeasures).concat(aInResults);
		resetFixedRole(aDorMs);
		if (!oValidation.valid) {
			aFeeds = fix(sChartType, oValidation, aFeeds, aDimensions, aMeasures);
			oValidation = validateFeeds("info/" + sChartType, aFeeds);
			// store fixed role in Dimension/Measure if fixed by BVR
			fixRole(sChartType, aFeeds, aDorMs);
		}

		if (oValidation.valid && aInResults && aInResults.length > 0) {
			var mVisDims = _groupBy(aDimensions, function(o) {return o.getName();});
			appendInResults(sChartType, aFeeds, aInResults.filter(function(oDim) {
				return !mVisDims[oDim.getName()];
			}));
		}

		var	mVisibles = aFeeds.reduce(function(map, f) {
			f.values.forEach(function(v) {
				map[v.id] = true;
			});
			return map;
		}, {});

		var aFeedItems = LwFeed.from(aFeeds);

		if (aContexts) {
			aContexts.forEach(function(ctx) {
				mVisibles[ctx.getName()] = true;
			});
			aFeedItems._context = aContexts.map(function(ctx) {
				var name = ctx.getName();
				var isShowInTooltip = true;
				for (var i = 0; i < continueSemanticTuples.length; i++) {
					if (name === continueSemanticTuples[i].actual || name === continueSemanticTuples[i].projected) {
						isShowInTooltip = false;
						break;
					}
				}
				return {
					id : name,
					showInTooltip : isShowInTooltip
				};
			});
		}

		aFeedItems._unused = unUsedDimsOrMsrs(aFeeds, aDimensions, aMeasures).filter(function(name) {
			return !mVisibles[name];
		});
		aFeedItems._def = createDefinitions(aDimensions, oValidation.valid ? aInResults : [], aMeasures, mVisibles, semanticTuples, isTimeChart(sChartType));
		aFeedItems._order = dimOrder(sChartType, aFeeds);
		aFeedItems._valid = oValidation.valid;
		aFeedItems._semanticTuples = semanticTuples;

		return aFeedItems;
	}

	function getBindingMap(sChartType) {
		return _groupBy(sap.viz.api.metadata.Viz.get("info/" + sChartType).bindings, "id");
	}

	function enforceFeedType(sChartType, aFeeds, mBindings) {
		mBindings = mBindings || getBindingMap(sChartType);
		aFeeds.forEach(function(oFeed) {
			oFeed.type = mBindings[oFeed.id][0].type;
		});
		return aFeeds;
	}

	function fix(sChartType, oValidation, aEffectiveFeeds, aDimensions, aMeasures) {
		var mBindings = getBindingMap(sChartType),
			bDimError = false,
			bMsrError = false;
		var mValidationBindings = oValidation.results.bindings;
		Object.keys(mValidationBindings).forEach(function(k) {
			if (!mBindings[k]) {
				return;
			}
			if (mBindings[k][0].type === "Measure") {
				bMsrError = true;
			}
			if (mBindings[k][0].type === "Dimension" && !(mValidationBindings[k].allowMND &&
					(!mValidationBindings[k].missing || mValidationBindings[k].missing === 1))) {
				bDimError = true;
			}
		});
		var aGoodFeeds = aEffectiveFeeds.filter(function(feed) {
			return !((feed.type === "Dimension") ? bDimError : bMsrError);
		}), mGoodDimOrMsr = aGoodFeeds.reduce(function(map, feed) {
			(feed.values || []).forEach(function(v) {
				map[v.id] = true;
			});
			return map;
		}, {});
		if (aEffectiveFeeds.contexts) {
			aEffectiveFeeds.contexts.forEach(function(ctx) {
				mGoodDimOrMsr[ctx.getName()] = true;
			});
		}
		var aDimAnalysisObjs = aDimensions.map(analysisObjectFmt("Dimension")),
			aMsrAnalysisObjs = aMeasures.map(analysisObjectFmt("Measure"));

		var aSuggested = suggestFeeds("info/" + sChartType, aGoodFeeds, aDimAnalysisObjs.concat(aMsrAnalysisObjs).filter(function(ao) {
			return !mGoodDimOrMsr[ao.id];
		})).feedItems;

		enforceFeedType(sChartType, aSuggested, mBindings);

		return aSuggested;
	}

	function unUsedDimsOrMsrs(aFeeds, aDimensions, aMeasures) {
		var	mUsed = aFeeds.reduce(function(map, f) {
			f.values.forEach(function(v) {
				map[v.id] = true;
			});
			return map;
		}, {});

		return aDimensions.concat(aMeasures).filter(function(n) {
			return !mUsed[n.getName()];
		}).map(function(n) {
			return n.getName();
		});
	}

	function createDefinitions(aDimensions, aInResults, aMeasures, mVisibles, aSemanticsMsrsRules, isTimeChart) {
		var oDateInstance;
		if (isTimeChart) {
			var timeAxis;
			for (var i = 0; i < aDimensions.length; i++) {
				if (aDimensions[i] instanceof sap.chart.data.TimeDimension) {
					timeAxis = aDimensions[i];
					break;
				}
			}
			oDateInstance = DateFormatUtil.getInstance(timeAxis.getTimeUnit());
		}
		return {
			dim: aDimensions.reduce(function(aVisibleDimDefs, oDim) {
				if (mVisibles[oDim.getName()]) {
					aVisibleDimDefs.push(wrapDimension(oDim, isTimeChart));
				}
				return aVisibleDimDefs;
			}, []).concat(aInResults.map(function(oDim) {
				var oDimDef = wrapDimension(oDim);
				oDimDef._setInResult(true);
				return oDimDef;
			})),
			msr: aMeasures.reduce(function(aVisibleMsrDefs, oMsr) {
				if (mVisibles[oMsr.getName()]) {
					aVisibleMsrDefs.push(wrapMeasure(oMsr));
				}
				return aVisibleMsrDefs;
			}, []).concat((aSemanticsMsrsRules || []).reduce(function(arr, rule){
				if (rule.timeAxis && rule.projectedValueStartTime) {
					arr.push(new MeasureDefinition({
						identity: rule.actual + "-" + rule.projected,
						name: ((rule.labels && rule.labels.actual) || rule.actual) + "-" + ((rule.labels && rule.labels.projected) || rule.projected),
						value: {
							parts: [rule.timeAxis, rule.actual, rule.projected],
							formatter : function(values) {
								var value = values, time;
								if (values && values.length > 1) {
									var date = values[0];
									if (date) {
										if (oDateInstance) {
											var parsedDate = oDateInstance.parse(date);
											if (parsedDate) {
												time = parsedDate.getTime();
											}
										} else {
											time = new Date(date).getTime();
										}
										if (time && (time < rule.projectedValueStartTime)) {
											value = values[1];
										} else {
											value = values[2];
										}
									}
								}
								return value;
							}
						}
					}));
				}
				return arr;
			}, []))
		};
	}

	return {
		fit: fit,
		compatible: function(sChartType, aDimensions, aMeasures) {
			var sInternalChartType = "info/" + sChartType,
				compatibility = {
					used: {},
					error: null,
					compatible: true
				};
			var aFeeds = fitBasic(sChartType, aDimensions, aMeasures),
				oValidation = validateFeeds(sInternalChartType, aFeeds);

			if (!oValidation.valid) {
				aFeeds = fix(sChartType, oValidation, aFeeds, aDimensions, aMeasures);
				oValidation = validateFeeds(sInternalChartType, aFeeds);
				compatibility.needFix = true;
			}
			if (oValidation.valid) {
				compatibility.used = _groupBy(aFeeds, function(oFeed) {
					return oFeed.type;
				}, function(oFeed) {
					return oFeed.values.filter(function(oVal) {
						return oVal.type === "Dimension" || oVal.type === "Measure";
					}).map(function(oVal) {
						return oVal.id;
					});
				});
				jQuery.each(compatibility.used, function(k, v) {
					compatibility.used[k] = v.reduce(function(aAll, aNames) {
						return aAll.concat(aNames);
					}, []);
				});
			} else {
				compatibility.compatible = false;
				var aChartFeedings = sap.viz.api.metadata.Viz.get(sInternalChartType).bindings,
					mFeedingByType = _groupBy(aChartFeedings, "type", function(o) {return o.id;}),
					mMissingByType = {dim: 0, msr: 0, time: 0};

				jQuery.each(oValidation.results.bindings, function(k, v) {
					if (!v.missing) { // only support missing error currently
						return;
					}
					if (mFeedingByType.Dimension.indexOf(k) !== -1 && !(v.allowMND && v.missing === 1)) {
						// for invalid feeding, since we do not suggest mnd during validation, so remove mnd error here
						mMissingByType[k === "timeAxis" ? "time" : "dim"] += v.missing;
					} else if (mFeedingByType.Measure.indexOf(k) !== -1) {
						mMissingByType.msr += v.missing;
					}
				});
				compatibility.error = {
					missing: mMissingByType
				};

			}

			return compatibility;
		}
	};
});

}; // end of sap/chart/utils/RoleFitter.js
if ( !jQuery.sap.isDeclared('sap.chart.library') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

/**
 * Initialization Code and shared classes of library sap.chart.
 */
jQuery.sap.declare('sap.chart.library'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('jquery.sap.global'); // unlisted dependency retained
jQuery.sap.require('sap.viz.ui5.format.ChartFormatter'); // unlisted dependency retained
jQuery.sap.require('sap.ui.core.library'); // unlisted dependency retained
jQuery.sap.require('sap.viz.library'); // unlisted dependency retained
sap.ui.define("sap/chart/library",[
	'jquery.sap.global',
	'sap/viz/ui5/format/ChartFormatter',
	'sap/ui/core/library', // library dependency
	'sap/viz/library',
	'sap/chart/utils/RoleFitter',
	'sap/chart/ChartType'
], function(jQuery, ChartFormatter, corelib, vizlib, RoleFitter, ChartType) {
	"use strict";

	/**
	 * Chart controls based on Vizframe
	 *
	 * @namespace
	 * @name sap.chart
	 * @public
	 */

	// delegate further initialization of this library to the Core
	sap.ui.getCore().initLibrary({
		name: "sap.chart",
		dependencies: ["sap.ui.core", "sap.viz"],
		types: [
			"sap.chart.data.MeasureSemantics"
		],
		interfaces: [],
		controls: [
			"sap.chart.Chart"
		],
		elements: [
			"sap.chart.data.Dimension",
			"sap.chart.data.TimeDimension",
			"sap.chart.data.Measure"
		],
		noLibraryCSS: true,
		version: "1.46.2"
	});


	/**
	 * @class
	 * Enumeration for supported selection mode in analytical chart
	 *
	 * @static
	 * @public
	 * @alias sap.chart.SelectionMode
	 */
	sap.chart.SelectionMode = {
		/**
		 * Multi selection mode, multiple sets of data points can be selected at once.
		 * @public
		 */
		Multi: "MULTIPLE",
		/**
		 * Single selection mode, only one set of data points can be selected at once.
		 * @public
		 */
		Single: "SINGLE",
		/**
		 * None selection mode, no data points can be selected.
		 * @public
		 */
		None : "NONE"
	};

	/**
	 * @class
	 * Enumeration for supported selection behavior in analytical chart
	 *
	 * @static
	 * @public
	 * @alias sap.chart.SelectionBehavior
	 */
	sap.chart.SelectionBehavior = {
		/**
		 * Data point selection behavior, only one data point can be selected at once.
		 * @public
		 */
		DataPoint: "DATAPOINT",
		/**
		 * Category selection behavior, one category of data points can be selected at once.
		 * @public
		 */
		Category: "CATEGORY",
		/**
		 * Series selection behavior, one seies of data points can be selected at once.
		 * @public
		 */
		Series: "SERIES"
	};
	
	/**
	 * @class
	 * Enumeration for supported message types in analytical chart.
	 *
	 * @static
	 * @public
	 * @alias sap.chart.MessageId
	 */
	sap.chart.MessageId = {
		/**
		 * No data message, metadata is defined but all data values are empty.
		 * @public
		 */
		NoData: "NO_DATA",
		/**
		 * Multiple units message, multiple unites are not allowed in one measure for analytical chart.
		 * @public
		 */
		MultipleUnits: "MULTIPLE_UNITS"
	};

	/**
	 * Package with additional chart APIs
	 * @namespace
	 * @public
	 */
	sap.chart.api = {};

	/**
	 * Returns all chart types currently supported by chart control (subset of viz types).
	 *
	 * @public
	 * @returns {object} a map with chartType as key, localized chart name as value.
	 */
	sap.chart.api.getChartTypes = function() {
		var sPath = jQuery.sap.getModulePath("sap.chart");
		var oBundle = jQuery.sap.resources({
			url: sPath + "/i18n/i18n.properties"
		});

		return Object.keys(sap.chart.ChartType).reduce(function(oMap, sChartTypeKey) {
			var sChartType = sap.chart.ChartType[sChartTypeKey];
			oMap[sChartType] = oBundle.getText("info/" + sChartType);
			return oMap;
		}, {});
	};

	/**
	 * Package with additional chart data APIs
	 * @namespace
	 * @public
	 */
	sap.chart.data = sap.chart.data || {};

	/**
	 * Enum of available semantics value for Measure.
	 *
	 * @enum {string}
	 * @public
	 */
	sap.chart.data.MeasureSemantics = {
		/**
		 * facts that happened in the past.
		 * @public
		 */
		Actual: "actual",
		/**
		 * where values will be, e.g.: forecasts, estimations, predictions.
		 * @public
		 */
		Reference: "reference",
		/**
		 * where values should be, e.g.: thresholds, targets.
		 * @public
		 */
		Projected: "projected"
	};

	/**
	 * Package with colorings enumeration
	 * @namespace
	 * @public
	 */
	sap.chart.coloring = sap.chart.coloring || {};

	/**
	 * Enum of available colorings.
	 *
	 * @enum {string}
	 * @public
	 */
	sap.chart.ColoringType = {
		/**
		 * Criticality is based on the semantic color palette. 
		 *
		 * It can be defined for measure values and dimension values.
		 * <pre>
		 * Criticality: {
         *     MeasureValues: {
         *         ...
         *     },
         *     DimensionValues: {
         *         ...
         *     }
		 * }
		 * </pre>
		 *
		 * <b>For measure values</b>, criticality can be based on <code>static</code>, <code>calculated</code>, <code>DynamicThresholds</code> and <code>ConstantThresholds</code>
		 *
		 * <code>Legend</code> is <b>optional</b> and can be used for custom legend labels.
		 * <pre>
         * MeasureValues: {
         *     'measureName': {
         *         Static: ... ,
         *         Calculated: ... ,
         *         DynamicThresholds: {
		 *             ...
         *         },
         *         ConstantThresholds: {
         *             ...
         *         },
         *         Legend: {
         *             Title: string,    // (optional) fixed, localized label
         *             Positive: string, // fixed, localized label
         *             Critical: string, // fixed, localized label
         *             Negative: string, // fixed, localized label
         *             Neutral:  string  // fixed, localized label
         *         }
         *     },
         *     'measureName': { 
         *         ...
         *     }
         * }
         * </pre>
		 * <ul>
		 *   <li><code>static</code>
		 *
		 *   It indicates that the measure is always considered in the same way, for example positive.
		 *
		 *   The value of <code>static</code> is listed in {@link sap.chart.coloring.CriticalityType}
		 *
		 *   Example:
		 *
		 *   In this case, all 'Profit' datapoints shall use Positive semantic color and all 'Revenue' datapoints shall use Negative semantic color.
		 *   <pre>
		 *   var oColorings = {
		 *       Criticality: {
         *           MeasureValues: {
         *               Profit: {
		 *                   Static: sap.chart.ColoringType.Positive
         *               },
         *               Revenue: {
		 *                   Static: sap.chart.ColoringType.Negative
		 *               }
         *           }
         *       }
		 *   };
		 *   var oActiveColoring = {
		 *       coloring: sap.chart.ColoringType.Criticality,
		 *       parameters: {
		 *           measure: ['Profit', 'Revenue']
		 *       }
		 *   };
		 *   </pre>
		 *   </li>
		 *   <li><code>Calculated</code>
		 *
		 *   Criticality is calculated by the backend service.
		 *
		 *   The value of <code>Calculated</code> is a dimension name. The criticality of the measure of a datapoint is determined by the value of this dimension
		 *   and its textProperty(if exists) will be used as legend label.
		 *
		 *   The possible values of this certain dimension are listed in {@link sap.chart.coloring.CriticalityType}.
		 *
		 *   Example:
		 *
		 *   In this case, the criticality of 'Profit' measure is determined by the value of 'ProfitCriticality' dimension which is calculated by backend service.
		 *   <pre>
		 *   var oColorings = {
		 *       Criticality: {
         *           MeasureValues: {
         *               Profit: {
		 *                   Calculated: 'ProfitCriticality'
         *               }
         *           }
         *       }
		 *   };
		 *   var oActiveColoring = {
		 *       coloring: sap.chart.ColoringType.Criticality,
		 *       parameters: {
		 *           measure: ['Profit']
		 *       }
		 *   };
		 *   </pre>
		 *   </li>
		 *   <li><code>DynamicThresholds</code>
		 *
		 *   Criticality is expressed with thresholds for the boundaries between negative, critical, and positive.
		 *
		 *   The direction of improvement for measure values is mandatory, combined with corresponding thresholds.
		 *
		 *   Please refer to {@link sap.chart.coloring.ImprovementDirectionType} for detailed usage.
		 *   <pre>
		 *   DynamicThresholds: {
         *       ImprovementDirection: string,    // refer to sap.chart.coloring.ImprovementDirectionType for detailed definition
         *       ToleranceRangeLowValue: string,  // measure name
         *       ToleranceRangeHighValue: string, // measure name
         *       DeviationRangeLowValue: string,  // measure name
         *       DeviationRangeHighValue: string, // measure name
         *   }
         *   </pre>
         *   Example:
		 *
		 *   In this case, the criticality of 'Profit' measure is determined by the value of 'ProfitToleranceRangeLowValue' and 'ProfitDeviationRangeLowValue' measure calculated with improvement direction <code>'Maximize'</code>.
		 *   <pre>
		 *   var oColorings = {
		 *       Criticality: {
         *           MeasureValues: {
         *               Profit: {
		 *                    DynamicThresholds : {
         *                        ImprovementDirection: sap.chart.coloring.ImprovementDirectionType.Maximize,
         *                        ToleranceRangeLowValue: 'ProfitToleranceRangeLowValue',
         *                        DeviationRangeLowValue: 'ProfitDeviationRangeLowValue'
		 *                    }
         *               }
         *           }
         *       }
		 *   };
		 *   var oActiveColoring = {
		 *       coloring: sap.chart.ColoringType.Criticality,
		 *       parameters: {
		 *           measure: ['Profit']
		 *       }
		 *   };
		 *   </pre>
		 *   </li>
		 *   <li><code>ConstantThresholds</code>
		 *
		 *   Criticality is expressed with thresholds for the boundaries between negative, critical, and positive.
		 *
		 *   The direction of improvement for measure values is mandatory, combined with corresponding thresholds.
		 *
		 *   Also Aggregation level (the visible dimensions) must be specified for providing the context for assessing the criticality.
		 *
		 *   Legend label is shown as value range and do not support customization in ConstantThresholds.
		 *
		 *   Please refer to {@link sap.chart.coloring.ImprovementDirectionType} for detailed usage. 
		 *   <pre>
		 *   ConstantThresholds: {
         *       ImprovementDirection: string, refer to sap.chart.coloring.ImprovementDirectionType for detailed definition
         *       AggregationLevels: [{
         *            VisibleDimensions: ['dimensionName', ...],
         *            ToleranceRangeLowValue: Number,
         *            ToleranceRangeHighValue: Number,
         *            DeviationRangeLowValue: Number,
         *            DeviationRangeHighValue: Number
         *       },
         *       ...]
         *   }
         *   </pre>
         *   Example:
		 *
		 *   In this case, the criticality of 'Profit' measure is determined by two concrete thresholds calculated with improvement direction <code>'Maximize'</code>.
		 *   <pre>
		 *   var oColorings = {
		 *       Criticality: {
         *           MeasureValues: {
         *               Profit: {
		 *                    ConstantThresholds : {
         *                        ImprovementDirection: sap.chart.coloring.ImprovementDirectionType.Maximize,
         *                        ToleranceRangeLowValue: 80,
         *                        DeviationRangeLowValue: 60
		 *                    }
         *               }
         *           }
         *       }
		 *   };
		 *   var oActiveColoring = {
		 *       coloring: sap.chart.ColoringType.Criticality,
		 *       parameters: {
		 *           measure: ['Profit']
		 *       }
		 *   };
		 *   </pre>
		 *   </li>
		 * </ul>
		 *
		 * <b>For dimension values</b>
		 *
		 * Criticality can be expressed by assigning values to negative, critical, and positive. Unassigned dimension values are automatically assigned to neutral.
		 *
		 * <code>'Values'</code> is used to specify concrete dimension value(s). <code>'Legend'</code> is used to customize legend label which is mandatory when multiple dimension values defined in <code>'Values'</code>.
		 *
		 * <pre> 
		 * DimensionValues: { 
		 *     'dimensionName': {
		 *          Positive: {
		 *              Values: 'dimensionValue' or ['dimensionValue', ...]
		 *              Legend: string // mandatory for value array
		 *          },
         *          Critical: {
         *              Values: 'dimensionValue' or ['dimensionValue', ...]
		 *              Legend: string // mandatory for value array
         *          },
         *          Negative: {
         *              Values: 'dimensionValue' or ['dimensionValue', ...]
		 *              Legend: string // mandatory for value array
         *          },
         *          Neutral: {
         *              Values: 'dimensionValue' or ['dimensionValue', ...]
		 *              Legend: string // mandatory for value array
         *          }
         *     },
         *     'dimensionName': {
         *         ... 
         *     } 
         * }
         * </pre>
         * Example:
		 *
		 * In this case, the criticality of 'OrderStatus' dimension is determined by values specified to different criticality classes.
		 * <pre>
		 * var oColorings = {
		 *     Criticality: {
         *         DimensionValues: {
         *             OrderStatus: {
		 *                  Positive : {
         *                      Values: 'Finished'
		 *                  },
		 *                  Critical : {
         *                      Values: 'Pending'
		 *                  },
		 *                  Negative : {
         *                      Values: ['Stopped', 'Not Started'],
         *                      Legend: 'Alert'
		 *                  },
		 *                  Neutral : {
         *                      Values: ['Processing', 'Surveyed'],
         *                      Legend: 'Normal'
		 *                  }
         *             }
         *         }
         *     }
		 * };
		 * var oActiveColoring = {
		 *     coloring: sap.chart.ColoringType.Criticality,
		 *     parameters: {
		 *         dimension: ['OrderStatus']
		 *     }
		 * };
		 * </pre>
		 * @public
		 */
		Criticality: "Criticality",
		/**
		 * Emphasis is about highlighting certain data points in a chart.
		 *
		 * It can be defined for dimension values.
		 * <pre>
		 * Emphasis: {
         *     DimensionValues: {
         *         ...
         *     }
		 * }
		 * </pre>
		 * <b>For dimension values</b>
		 *
		 * Highlight a specified set of values of a dimension visible in the current chart layout. The qualitative color palette is used.
		 *
		 * <code>'Values'</code> is used to specify dimension value(s) for highlight. <code>'Legend'</code> is used to customize legend label whose <code>'Hightlighted'</code> is mandatory when multiple dimension values defined in <code>'Values'</code>.
		 * <pre>
		 * DimensionValues: {
         *     'dimensionName': {
         *         Values: 'dimensionValue' or ['dimensionValue', ...],
         *         Legend: {
         *            Highlighted: string // mandatory for value array
         *            Others: string      // optional
         *         }
         *     },
         *     'dimensionName': {
         *         ...
         *     }
         * }
		 * </pre>
		 * Example:
		 *
		 * In this case, 'German' and 'France' are highlighted in 'Country' dimension with customized legend label 'Europe'.
		 * <pre>
		 * var oColorings = {
		 *     Emphasis: {
         *         DimensionValues: {
         *             Country: {
         *                 Values: ['German', 'France']
         *                 Legend: 'Europe'
		 *             }
         *         }
         *     }
		 * };
		 * var oActiveColoring = {
		 *     coloring: sap.chart.ColoringType.Emphasis,
		 *     parameters: {
		 *         dimension: ['Country']
		 *     }
		 * };
		 * </pre>
		 * @public
		 */
		Emphasis: "Emphasis"
	};

	/**
	* Enumeration for supported criticality types in analytical chart
	*
	* @enum {string}
	* @public
	* @alias sap.chart.coloring.CriticalityType
	*/
	sap.chart.coloring.CriticalityType = {
		/**
		 * Negative
		 * @public
		 */
		Negative: "Negative",

		/**
		 * Critical
		 * @public
		 */
		Critical: "Critical",

		/**
		 * Positive
		 * @public
		 */
		Positive: "Positive",

		/**
		 * Neutral
		 * @public
		 */
		Neutral: "Neutral"
	};

	/**
	* Enumeration for supported ImprovementDirection types in analytical chart
	*
	* @enum {string}
	* @public
	* @alias sap.chart.coloring.ImprovementDirectionType
	*/
	sap.chart.coloring.ImprovementDirectionType = {
		/**
		 * Lower is better.
		 * 
		 * Positive if the value is lower than or equal to <code>ToleranceRangeHighValue</code>.
		 * 
		 * Critical if the value is greater than <code>ToleranceRangeHighValue</code> and lower than or equal to <code>DeviationRangeHighValue</code>.
		 * 
		 * Negative if the value is greater than <code>DeviationRangeHighValue</code>.
		 * @public
		 */
		Minimize: "Minimize",

		/**
		 * Closer to the target is better.
		 * 
		 * Positive if the value is greater than or equal to <code>ToleranceRangeLowValue</code> and lower than or equal to <code>ToleranceRangeHighValue</code>.
		 * 
		 * Critical if the value is greater than or equal to <code>DeviationRangeLowValue</code> and lower than <code>ToleranceRangeLowValue</code> OR greater than <code>ToleranceRangeHighValue</code> and lower than or equal to <code>DeviationRangeHighValue</code>.
		 * 
		 * Negative if the value is lower than <code>DeviationRangeLowValue</code> or greater than <code>DeviationRangeHighValue</code>.
		 * @public
		 */
		Target: "Target",

		/**
		 * Higher is better.
		 * 
		 * Positive if the value is greater than or equal to <code>ToleranceRangeLowValue</code>.
		 * 
		 * Critical if the value is lower than <code>ToleranceRangeLowValue</code> and greater than or equal to <code>DeviationRangeLowValue</code>.
		 * 
		 * Negative if the value is lower than <code>DeviationRangeLowValue</code>.
		 * @public
		 */
		Maximize: "Maximize"
	};

	/**
	 * Get the Dimensions and Measures layout for a certain ChartType with provided Dimensions and Measures.
	 *
	 * @param {string} sChartType chart type
	 * @param {object[]} aDimensions visible Dimensions of the form {name: sName}
	 * @param {object[]} aMeasures visible Measures of the form {name: sName}.
	 *
	 * @public
	 * @returns {object} the chart layout object of the following form:
	 * <pre>
	 * {
	 *   dimensions: [],     // names of dimensions that will be rendered
	 *	 measures:	 [],     // names of measures that will be rendered
	 *	 errors:	 [],     // reasons of why the chart cannot be rendered with the given (chartType, dimensions, measures) combination
	 * }
	 */
	sap.chart.api.getChartTypeLayout = function(sChartType, aDimensions, aMeasures) {
		var aDims, aMsrs;
		if (!sChartType) {
			throw new Error("Invalid chart type: " + String(sChartType));
		}
		if (aDimensions) {
			aDims = aDimensions.map(function(oDimCfg, i) {
				if (oDimCfg && oDimCfg.name) {
					return {
						getName: function() {return oDimCfg.name;},
						getRole: function() {return oDimCfg.role || "category";}
					};
				} else {
					throw new Error("Invalid Dimension at [" + i + "]: " + String(oDimCfg) + ". Dimension should be an object of the format{name:'name'}.");
				}
			});
		} else {
			aDims = [];
		}
		if (aMeasures) {
			aMsrs = aMeasures.map(function(oMsrCfg, i) {
				if (oMsrCfg && oMsrCfg.name) {
					return {
						getName: function() {return oMsrCfg.name;},
						getRole: function() {return oMsrCfg.role || "axis1";}
					};
				} else {
					throw new Error("Invalid Measure at [" + i + "]: " +  String(oMsrCfg) + ". Measure should be an object of the format{name:'name'}.");
				}
			});
		} else {
			aMsrs = [];
		}

		var oCompatibility = RoleFitter.compatible(sChartType, aDims, aMsrs);

		return {
			dimensions: oCompatibility.used.Dimension || [],
			measures: oCompatibility.used.Measure || [],
			errors: Object.keys(oCompatibility.error || {}).reduce(function(aErrs, sCause) {
				return aErrs.concat({cause: sCause, detail: oCompatibility.error[sCause]});
			}, [])
		};
	};

	var FIORI_LABEL_SHORTFORMAT_10 = "__UI5__ShortIntegerMaxFraction10";
	var FIORI_LABEL_FORMAT_2 = "__UI5__FloatMaxFraction2";
	var FIORI_LABEL_SHORTFORMAT_2 = "__UI5__ShortIntegerMaxFraction2";

	var chartFormatter = ChartFormatter.getInstance();
	chartFormatter.registerCustomFormatter(FIORI_LABEL_SHORTFORMAT_10, function(value) {
		var fixedInteger = sap.ui.core.format.NumberFormat.getIntegerInstance({style: "short",
			maxFractionDigits: 10});
		return fixedInteger.format(value);
	});
	chartFormatter.registerCustomFormatter(FIORI_LABEL_FORMAT_2, function(value) {
		var fixedFloat = sap.ui.core.format.NumberFormat.getFloatInstance({style: 'Standard',
			maxFractionDigits: 2});
		return fixedFloat.format(value);
	});
	chartFormatter.registerCustomFormatter(FIORI_LABEL_SHORTFORMAT_2, function(value) {
		var fixedInteger = sap.ui.core.format.NumberFormat.getIntegerInstance({style: "short",
			maxFractionDigits: 2});
		return fixedInteger.format(value);
	});
	this._oChartForamtter = chartFormatter;

	if (!(sap.viz.api.env.Format.numericFormatter() instanceof ChartFormatter)) {
		sap.viz.api.env.Format.numericFormatter(chartFormatter);
	}

	return sap.chart;

});

}; // end of sap/chart/library.js
if ( !jQuery.sap.isDeclared('sap.chart.coloring.criticality.DimensionValues') ) {
jQuery.sap.declare('sap.chart.coloring.criticality.DimensionValues'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/coloring/criticality/DimensionValues",[
	'sap/chart/coloring/ColoringUtils',
	'sap/chart/ChartLog',
	'sap/chart/library',
	'sap/chart/data/TimeDimension'
], function(
	ColoringUtils,
	ChartLog,
	chartLibrary,
	TimeDimension
) {
	"use strict";
	var type = jQuery.type;
	var CriticalityType = chartLibrary.coloring.CriticalityType;

	var Dim = {};
	var validate = function(oMatchedDim, aMsr, aDim, aInResultDims, sColoringType, options) {
		var sRole = oMatchedDim._getFixedRole();
		var sComponent = 'Colorings.' + sColoringType + '.DimensionValues';
		if (oMatchedDim instanceof TimeDimension && oMatchedDim._getFixedRole() === "category") {
			//clid21, clid22
			throw new ChartLog('error', sComponent, 'Do not support ' + sColoringType + ' on timeAxis');
		}
		if (aInResultDims.length) {
			//clid15
			throw new ChartLog('error', sComponent, 'InResult dimension is not allowed in dimension based Criticality');
		}
		var aSeriesDims = aDim.filter(function(oDim) {
			return oDim._getFixedRole() === "series";
		});
		var aCategoryDims = aDim.filter(function(oDim) {
			return oDim._getFixedRole() === "category";
		});

		if (sRole === "category" && !options.bIsPie) {
			if (options.chartType !== "waterfall") {
				if (aSeriesDims.length > 0 || aMsr.length > 1) {
					//clid16
					throw new ChartLog('error', sComponent, 'Existing color legend shall not be changed in Criticality');
				}
			}
		} else if (sRole === "series" || options.bIsPie) {
			var bValid = false;
			switch (options.chartType) {
				case "bubble":
					if (aSeriesDims.length === 1) {
						bValid = true;
					}
					break;
				case "waterfall":
					//waterfall's mnd is always on category
					bValid = true;
					break;
				case "pie":
				case "donut":
					var aAllDims = aSeriesDims.concat(aCategoryDims);
					if (aMsr.length === 1 && aAllDims.length === 1) {
						bValid = true;
					}
					break;
				default:
					// general xy chart
					if (aMsr.length === 1 ||
						(aMsr.length > 1 && aCategoryDims.length === 0)) {
						// only mnd on category or single measure on series
						if (aSeriesDims.length === 0 ||
							(sColoringType === "Criticality" && aSeriesDims.length === 1 && aSeriesDims[0] === oMatchedDim)) {
							//no mnd or dim on series
							bValid = true;
						}
					}
			}
			if (!bValid) {
				//clid16
				throw new ChartLog('error', sComponent, 'Existing color legend shall not be changed in Criticality');
			}
		}
		return;
	};

	Dim.qualify = function(oConfig, aMsr, aDim, aInResultDims, oActiveColoring, sColoringType, options) {
		var sDimName, oCandidateSetting;
		sColoringType = sColoringType || "Criticality";
		var sComponent = 'Colorings.' + sColoringType + '.DimensionValues';

		if (options.bMBC) {
			//clid23
			throw new ChartLog('error', 'Colorings', 'Heatmap only support Criticality.MeasureValues.ConstantThresholds');
		}

		if (!oActiveColoring.parameters || !oActiveColoring.parameters.dimension) {
			if (oConfig) {
				var aKeys = Object.keys(oConfig);
				if (aKeys.length > 1) {
					//clid12
					throw new ChartLog('error', sComponent, 'Multiple dimensions are defined, please resolve by activeColoring property');
				} else if (aKeys.length === 1) {
					sDimName = aKeys[0];
				} else {
					return null;
				}
			}
		} else {
			sDimName = oActiveColoring.parameters.dimension;
		}
		
		if (sDimName) {
			var oMatchedDim = ColoringUtils.find(sDimName, aDim);
			if (!oMatchedDim || !oConfig[sDimName]) {
				//clid13
				throw new ChartLog('error', sComponent, 'Active dimension should be visible');
			} else {
				oCandidateSetting = {
					dim: sDimName,
					setting: oConfig
				};
				validate(oMatchedDim, aMsr, aDim, aInResultDims, sColoringType, options);
			}
		}

		return oCandidateSetting;
	};

	Dim.parse = function(oConfig, aDim, oStatus, oLocale, options) {
		var oSetting = {};
		var oLegend = {};
		var sDimName = oConfig.dim;
		var aCriticalityValues = [];
		var sRole = ColoringUtils.find(sDimName, aDim)._getFixedRole();
		var oDimConfig = oConfig.setting[sDimName];

		// validate settings
		jQuery.each(oDimConfig, function(key, val) {
			var alevels = (type(val) !== "array") ? [val] : val;
			alevels.forEach(function(lvl) {
				var aValues = (type(lvl.Values) !== "array") ? [lvl.Values] : lvl.Values;
				if (aValues.length > 1) {
					if (!lvl.Legend) {
						//clid14
						throw new ChartLog('error', 'Colorings.Criticality.DimensionValues', 'Legend is mandatory when one criticality type has multiple values');
					} else if (sRole === "series" || options.bIsPie) {
						//clid16
						throw new ChartLog('error', 'Colorings.Criticality.DimensionValues', 'Existing color legend shall not be changed in Criticality');
					}
				}
			});
		});

		jQuery.each(oDimConfig, function(key, val) {
			var alevels = (type(val) !== "array") ? [val] : val;
			if (key !== CriticalityType.Neutral) {
				oSetting[key] = alevels.map(function(level) {
					return (type(level.Values) === "array") ? level.Values : [level.Values];
				});
				aCriticalityValues = Array.prototype.concat.apply(aCriticalityValues, oSetting[key]);
			}
			oLegend[key] = alevels.map(function(level) {
				var sVal = (type(level.Values) === "array") ? level.Values[0] : level.Values;
				var sLegend = (level.Legend != null) ? level.Legend : sVal;
				return sLegend;
			});
		});

		var fnNeutralCb = function (oCtx) {
			return aCriticalityValues.indexOf(oCtx[sDimName]) === -1;
		};

		var aNeutralValues = [];
		if (oDimConfig.Neutral) {
			aNeutralValues = (type(oDimConfig.Neutral.Values) === "array") ? oDimConfig.Neutral.Values : [oDimConfig.Neutral.Values];
		}

		var oNeutralInfo = {
			callback: [fnNeutralCb],
			NeutralValues: aNeutralValues,
			CriticalityValues: aCriticalityValues
		};

		function genChecker(aValues) {
			return function(oCtx) {
				return aValues.indexOf(oCtx[sDimName]) !== -1;
			};
		}
		var mCallbacks = {
			Negative: (oSetting.Negative || []).map(genChecker),
			Critical: (oSetting.Critical || []).map(genChecker),
			Positive: (oSetting.Positive || []).map(genChecker)
		};

		return {
			callbacks: mCallbacks,
			legend: oLegend,
			NeutralInfo: oNeutralInfo,
			status: oStatus
		};
	};

	Dim.getContextHandler = function(oCandidateSetting, oLocale) {
		var sDim = oCandidateSetting.dim;
		var oNeutralInfo = oCandidateSetting.parsed.NeutralInfo;

		return function(oContext) {
			var sVal = oContext.getProperty(sDim);
			var status = oCandidateSetting.parsed.status;
			var oCriticalityDim = this.getDimensionByName(sDim);
			if (oNeutralInfo.CriticalityValues.indexOf(sVal) === -1) {
				// non-criticality value
				if (!status.singleOtherValue) {
					status.singleOtherValue = sVal;
				} else if (status.singleOtherValue !== sVal && oCriticalityDim._getFixedRole() === "series") {
					//clid16
					var oChartLog = new ChartLog('error', 'Colorings.Criticality.DimensionValues', 'Existing color legend shall not be changed in Criticality');
					oCandidateSetting.chartLog = oChartLog;
				}

				oCandidateSetting.parsed.callbacks.Neutral = oNeutralInfo.callback;
				if (oNeutralInfo.NeutralValues.indexOf(sVal) === -1) {
					// other value not in Neutral
					oCandidateSetting.parsed.legend.Neutral = oLocale.getText("COLORING_TYPE_OTHER");
				}
			}
		};
	};

	return Dim;
});

}; // end of sap/chart/coloring/criticality/DimensionValues.js
if ( !jQuery.sap.isDeclared('sap.chart.coloring.criticality.measureValues.ThresholdsUtils') ) {
jQuery.sap.declare('sap.chart.coloring.criticality.measureValues.ThresholdsUtils'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/coloring/criticality/measureValues/ThresholdsUtils",[
	'sap/chart/coloring/ColoringUtils',
	'sap/chart/library'
], function(
	ColoringUtils,
	chartLibrary
) {
	"use strict";
	var Thresholds = {};

	var Msr = {
		formulas: {}
	};

	var NEGATIVE = chartLibrary.coloring.CriticalityType.Negative;
	var CRITICAL = chartLibrary.coloring.CriticalityType.Critical;
	var POSITIVE = chartLibrary.coloring.CriticalityType.Positive;

	function genSegment(iUpperBound, sCriticalityType, iLvl) {
		return {
			upperBound: iUpperBound,
			CriticalityType: sCriticalityType,
			level: iLvl
		};
	}

	Thresholds.MBCimprovement = function(sDir, oTolRange, oDevRange) {
		var aSegments = [];
		var aBoundaryOrder, aCriticalityOrder;
		switch (sDir) {
			case 'maximize':
				aBoundaryOrder = [oDevRange.lo, oTolRange.lo, Number.POSITIVE_INFINITY];
				aCriticalityOrder = [NEGATIVE, CRITICAL, POSITIVE];
				break;
			case 'minimize':
				aBoundaryOrder = [oTolRange.hi, oDevRange.hi, Number.POSITIVE_INFINITY];
				aCriticalityOrder = [POSITIVE, CRITICAL, NEGATIVE];
				break;
			case 'target':
				aBoundaryOrder = [oDevRange.lo, oTolRange.lo, oTolRange.hi, oDevRange.hi, Number.POSITIVE_INFINITY];
				aCriticalityOrder = [NEGATIVE, CRITICAL, POSITIVE, CRITICAL, NEGATIVE];
				break;
			default:
		}
		aSegments = aCriticalityOrder.map(function(sCriticalityType, index) {
			return genSegment(aBoundaryOrder[index], sCriticalityType, 0);
		});
		return {
			segments: aSegments,
			min: Number.POSITIVE_INFINITY,
			max: Number.NEGATIVE_INFINITY
		};
	};

	Thresholds.improvement = function(sDir, sMsr, oTolRange, oDevRange, oBreakdown) {
		var devLoFn = ColoringUtils.thresholdValue(oDevRange.lo);
		var tolLoFn = ColoringUtils.thresholdValue(oTolRange.lo);
		var devHiFn = ColoringUtils.thresholdValue(oDevRange.hi);
		var tolHiFn = ColoringUtils.thresholdValue(oTolRange.hi);

		var nNeg = ColoringUtils.assertLevel(oBreakdown, 'NegativeLevels');
		var nCrt = ColoringUtils.assertLevel(oBreakdown, 'CriticalLevels');
		var nPos = ColoringUtils.assertLevel(oBreakdown, 'PositiveLevels');
		var minFn = ColoringUtils.thresholdValue(oBreakdown.MinimumMeasureValue);
		var maxFn = ColoringUtils.thresholdValue(oBreakdown.MaximumMeasureValue);

		switch (sDir) {
			case 'maximize':
				return {
					Negative: ColoringUtils.genLevels(nNeg, Msr.formulas.maximize.negative(sMsr, nNeg, minFn, devLoFn)),
					Critical: ColoringUtils.genLevels(nCrt, Msr.formulas.maximize.critical(sMsr, nCrt, devLoFn, tolLoFn)),
					Positive: ColoringUtils.genLevels(nPos, Msr.formulas.maximize.positive(sMsr, nPos, tolLoFn, maxFn))
				};
			case 'minimize':
				return {
					Negative: ColoringUtils.genLevels(nNeg, Msr.formulas.minimize.negative(sMsr, nNeg, devHiFn, maxFn)),
					Critical: ColoringUtils.genLevels(nCrt, Msr.formulas.minimize.critical(sMsr, nCrt, tolHiFn, devHiFn)),
					Positive: ColoringUtils.genLevels(nPos, Msr.formulas.minimize.positive(sMsr, nPos, minFn, tolHiFn))
				};
			case 'target':
				return {
					Negative: ColoringUtils.genLevels(nNeg, Msr.formulas.target.negative(sMsr, nNeg, devLoFn, devHiFn, minFn, maxFn)),
					Critical: ColoringUtils.genLevels(nCrt, Msr.formulas.target.critical(sMsr, nCrt, devLoFn, tolLoFn, tolHiFn, devHiFn)),
					Positive: ColoringUtils.genLevels(nPos, Msr.formulas.target.positive(sMsr, nPos, tolLoFn, tolHiFn))
				};
			default:
				throw new Error('Unsupported ImprovementDirection: ' + sDir);
		}
	};

	Msr.formulas.maximize = {
		negative: function(sMsrName, nLvl, fnMin, fnDevLo) {
			return function(oCtx) {
				var nVal = oCtx[sMsrName];
				var nMin = fnMin(oCtx);
				var nHi = fnDevLo(oCtx);
				if (!ColoringUtils.isInRange(nVal, Number.NEGATIVE_INFINITY, nHi, null, false)) {
					return -1;
				} else if (!ColoringUtils.isNumber(nLvl, nMin) || nLvl <= 1) {
					return 1;
				} else if (nVal < nMin) {
					return nLvl;
				} else {
					return (nLvl - 1) - Math.floor((nLvl - 1) * (nVal - nMin) / (nHi - nMin));
				}
			};
		},
		critical: function(sMsrName, nLvl, fnDevLo, fnTolLo) {
			return function(oCtx) {
				var nVal = oCtx[sMsrName];
				var nLo = fnDevLo(oCtx);
				var nHi = fnTolLo(oCtx);

				if (!ColoringUtils.isInRange(nVal, nLo, nHi, true, false)) {
					return -1;
				} else if (!ColoringUtils.isNumber(nLvl) || nLvl <= 1) {
					return 1;
				} else {
					return nLvl - Math.floor(nLvl * (nVal - nLo) / (nHi - nLo));
				}
			};
		},
		positive: function(sMsrName, nLvl, fnTolLo, fnMax) {
			return function(oCtx) {
				var nVal = oCtx[sMsrName];
				var nMax = fnMax(oCtx);
				var nLo = fnTolLo(oCtx);
				if (!ColoringUtils.isInRange(nVal, nLo, Number.POSITIVE_INFINITY, true)) {
					return -1;
				} else if (!ColoringUtils.isNumber(nLvl, nMax) || nLvl <= 1) {
					return 1;
				} else if (nVal >= nMax) {
					return nLvl;
				} else {
					return Math.floor((nLvl - 1) * (nVal - nLo) / (nMax - nLo)) + 1;
				}
			};
		}
	};

	Msr.formulas.minimize = {
		negative: function(sMsrName, nLvl, fnDevHi, fnMax) {
			return function(oCtx) {
				var nVal = oCtx[sMsrName];
				var nMax = fnMax(oCtx);
				var nLo = fnDevHi(oCtx);

				if (!ColoringUtils.isInRange(nVal, nLo, Number.POSITIVE_INFINITY, false)) {
					return -1;
				} else if (!ColoringUtils.isNumber(nLvl, nMax) || nLvl <= 1) {
					return 1;
				} else if (nVal > nMax) {
					return nLvl;
				} else {
					return Math.floor((nLvl - 1) * (nVal - nLo) / (nMax - nLo)) + 1;
				}
			};
		},
		critical: function(sMsrName, nLvl, fnTolHi, fnDevHi) {
			return function(oCtx) {
				var nVal = oCtx[sMsrName];
				var nLo = fnTolHi(oCtx);
				var nHi = fnDevHi(oCtx);
				if (!ColoringUtils.isInRange(nVal, nLo, nHi, false, true)) {
					return -1;
				} else if (!ColoringUtils.isNumber(nLvl) || nLvl <= 1) {
					return 1;
				} else {
					return Math.floor(nLvl * (nVal - nLo) / (nHi - nLo)) + 1;
				}
			};
		},
		positive: function(sMsrName, nLvl, fnMin, fnTolHi) {
			return function(oCtx) {
				var nVal = oCtx[sMsrName];
				var nMin = fnMin(oCtx);
				var nHi = fnTolHi(oCtx);

				if (!ColoringUtils.isInRange(nVal, Number.NEGATIVE_INFINITY, nHi, null, true)) {
					return -1;
				} else if (!ColoringUtils.isNumber(nLvl, nMin) || nLvl <= 1) {
					return 1;
				} else if (nVal < nMin) {
					return nLvl;
				} else {
					return (nLvl - 1) - Math.floor((nLvl - 1) * (nVal - nMin) / (nHi - nMin));
				}
			};
		}
	};

	Msr.formulas.target = {
		negative: function(sMsrName, nLvl, fnDevLo, fnDevHi, fnMin, fnMax) {
			return function(oCtx) {
				var nVal = oCtx[sMsrName];
				var nLeftHi = fnDevLo(oCtx);
				var nRightLo = fnDevHi(oCtx);
				var nMin = fnMin(oCtx);
				var nMax = fnMax(oCtx);

				var inLeft = ColoringUtils.isInRange(nVal, Number.NEGATIVE_INFINITY, nLeftHi, null, false);
				var inRight = ColoringUtils.isInRange(nVal, nRightLo, Number.POSITIVE_INFINITY, false);

				if (!inLeft && !inRight) {
					return -1;
				} else if (!ColoringUtils.isNumber(nLvl) || nLvl <= 1) {
					return 1;
				} else if (inLeft) {
					if (nVal < nMin) {
						return nLvl;
					} else {
						return nLvl - (Math.floor((nVal - nMin) / ((nLeftHi - nMin) / (nLvl - 1))) + 1);
					}
				} else {
					if (nVal >= nMax) {
						return nLvl;
					} else {
						return nLvl - (Math.floor((nMax - nVal) / ((nMax - nRightLo) / (nLvl - 1))) + 1);
					}
				}
			};
		},
		critical: function(sMsrName, nLvl, fnDevLo, fnTolLo, fnTolHi, fnDevHi) {
			return function(oCtx) {
				var nVal = oCtx[sMsrName];
				var nLeftLo = fnDevLo(oCtx),
					nLeftHi = fnTolLo(oCtx);
				var nRightLo = fnTolHi(oCtx),
					nRightHi = fnDevHi(oCtx);

				var inLeft = ColoringUtils.isInRange(nVal, nLeftLo, nLeftHi, true, false);
				var inRight = ColoringUtils.isInRange(nVal, nRightLo, nRightHi, false, true);

				if (!inLeft && !inRight) {
					return -1;
				} else if (!ColoringUtils.isNumber(nLvl) || nLvl <= 1) {
					return 1;
				} else if (inLeft) {
					return nLvl - Math.floor((nVal - nLeftLo) / ((nLeftHi - nLeftLo) / nLvl));
				} else {
					return Math.floor((nRightHi - nVal) / ((nRightHi - nRightLo) / nLvl)) + 1;
				}
			};
		},
		positive: function(sMsrName, nLvl, fnTolLo, fnTolHi) {
			return function(oCtx) {
				var nVal = oCtx[sMsrName];
				var nLo = fnTolLo(oCtx);
				var nHi = fnTolHi(oCtx);

				if (!ColoringUtils.isInRange(nVal, nLo, nHi, true, true)) {
					return -1;
				} else if (!ColoringUtils.isNumber(nLvl) || nLvl <= 1) {
					return 1;
				} else {
					return Math.min(nLvl, nLvl + 1 - Math.ceil(Math.abs(nVal - (nLo + (nHi - nLo) / 2)) / ((nHi - nLo) / (2 * nLvl))));
				}
			};
		}
	};

	return Thresholds;
});
}; // end of sap/chart/coloring/criticality/measureValues/ThresholdsUtils.js
if ( !jQuery.sap.isDeclared('sap.chart.coloring.emphasis.DimensionValues') ) {
jQuery.sap.declare('sap.chart.coloring.emphasis.DimensionValues'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/coloring/emphasis/DimensionValues",[
	'sap/chart/coloring/ColoringUtils',
	'sap/chart/coloring/criticality/DimensionValues',
	'sap/chart/ChartLog'
], function(
	ColoringUtils,
	DimensionValues,
	ChartLog
) {
	"use strict";
	var type = jQuery.type;
	
	var Dim = {};
	Dim.qualify = function(oConfig, aMsr, aDim, aInResultDims, oActiveColoring, options) {
		return DimensionValues.qualify(oConfig, aMsr, aDim, aInResultDims, oActiveColoring, "Emphasis", options);
	};

	Dim.parse = function(oConfig, oLocale) {
		var oLegend = {};
		var sDimName = oConfig.dim;
		var oDimConfig = oConfig.setting[sDimName];

		var values = oDimConfig.Values;
		var aHighlightedValues = (type(values) === "array") ? values : [values];
		var fnHightlightCb = function (oCtx) {
			return aHighlightedValues.indexOf(oCtx[sDimName]) > -1;
		};

		if (aHighlightedValues.length > 1 && !(oDimConfig.Legend && oDimConfig.Legend.Highlighted)) {
			//clid19
			throw new ChartLog('error', 'Colorings.Emphasis.DimensionValues', 'Legend.Highlighted is mandatory when Highlight has multiple values');
		} else {
			if (oDimConfig.Legend && oDimConfig.Legend.Highlighted != null) {
				oLegend.Highlight = oDimConfig.Legend.Highlighted;
			} else {
				oLegend.Highlight = aHighlightedValues[0];
			}
		}
		if (oDimConfig.Legend && oDimConfig.Legend.Others) {
			oLegend.Others = oDimConfig.Legend.Others;
		} else {
			oLegend.Others = oLocale.getText("COLORING_TYPE_OTHER");
		}

		var mCallbacks = {
			Highlight: fnHightlightCb
		};

		return {
			callbacks: mCallbacks,
			legend: oLegend
		};
	};

	return Dim;
});

}; // end of sap/chart/coloring/emphasis/DimensionValues.js
if ( !jQuery.sap.isDeclared('sap.chart.coloring.emphasis.Emphasis') ) {
/*
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.chart.coloring.emphasis.Emphasis'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/coloring/emphasis/Emphasis",[
	'sap/chart/coloring/emphasis/DimensionValues',
	'sap/chart/coloring/ColorPalette',
	'sap/chart/ChartLog'
], function(
	DimensionValues,
	ColorPalette,
	ChartLog
) {
	"use strict";
	var SUPPORTED_TYPES = ['DimensionValues', 'MeasureValues'];

	function use(oColorings, oActiveCriticalityColoring) {
		var oParams = oActiveCriticalityColoring ? oActiveCriticalityColoring.parameters : {};
		var types = Object.keys(oColorings).filter(function(sType) {
			return !SUPPORTED_TYPES.indexOf(sType) !== -1;
		});

		if (oParams && oParams.dimension && oParams.measure) {
			//clid3
			throw new ChartLog('error', 'colorings.Emphasis', 'Both "DimensionValues" and "MeasureValues" present in coloring EMPHASIS, activeColoring.parameters is required to specify which to use');
		} else if (oParams && oParams.dimension) {
			return 'DimensionValues';
		} else if (oParams && oParams.measure) {
			return 'MeasureValues';
		} else if (types.length === 1) {
			return types[0];
		} else {
			return null;
		}
	}

	function createRules(aCandidateSettings, aLegendOrder) {
		var oCandidateSetting = aCandidateSettings[0];
		var aCbs = oCandidateSetting.parsed.callbacks.Highlight || [];
		var oLegend = oCandidateSetting.parsed.legend;
		var aRules = [];
		aRules.push({
			callback: aCbs,
			properties: {
				color: ColorPalette.EMPHASIS.Highlight
			},
			displayName: oLegend.Highlight
		});

		var oOthers = {
			properties: {
				color: ColorPalette.EMPHASIS.Others
			},
			displayName: oLegend.Others
		};

		return {
			rules: aRules,
			others: oOthers
		};
	}

	function getRuleGenerator(aCandidateSettings, aLegendOrder) {
		return function() {
			var props = {
				plotArea: {
					dataPointStyle: createRules(aCandidateSettings)
				}
			};
			return {
				properties: props
			};
		};
	}

	return {
		getCandidateSetting: function(oColorings, oActiveColoring, aMsr, aDim, aInResultDims, oStatus, options, oLocale) {
			var oEmphasis = oColorings.Emphasis || {};
			var sUseType = use(oEmphasis, oActiveColoring);
			var aQualifiedSettings;

			switch (sUseType) {
				case 'DimensionValues':
					aQualifiedSettings = DimensionValues.qualify(oEmphasis.DimensionValues, aMsr, aDim, aInResultDims, oActiveColoring, options);
					if (aQualifiedSettings) {
						aQualifiedSettings.parsed = DimensionValues.parse(aQualifiedSettings, oLocale);
						aQualifiedSettings.ruleGenerator = getRuleGenerator([aQualifiedSettings]);
					}
					break;
				default:
					return {};
			}

			return aQualifiedSettings;
		}
	};
});

}; // end of sap/chart/coloring/emphasis/Emphasis.js
if ( !jQuery.sap.isDeclared('sap.chart.data.Measure') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.chart.data.Measure'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained
sap.ui.define("sap/chart/data/Measure",[
	"sap/ui/core/Element",
	"sap/chart/utils/ChartUtils",
	"sap/chart/library"
], function(
	Element,
	ChartUtils,
	library
) {
	"use strict";
	var _SUPPORTED_ROLE = {axis1:true,axis2:true,axis3:true,axis4:true};
	var MeasureSemantics = library.data.MeasureSemantics;
	
	/**
	 * Constructor for a new ui5/data/Measure.
	 *
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 *
	 * @class
	 * Definition of a single measure in a chart
	 * @extends sap.ui.core.Element
	 *
	 * @constructor
	 * @public
	 * @since 1.32.0
	 * @name sap.chart.data.Measure
	 */
	var Measure = Element.extend("sap.chart.data.Measure", {
		metadata: {
			library : "sap.chart",
			properties: {
				/**
				 * Property in the "data" model holding the raw measure value.
				 */
				name: {type: "string"},
				/**
				 * Label for the Measure, either as a string literal or by a pointer using the binding syntax to some property containing the label.
				 */
				label: {type: "string"},
				// Need to discuss behavior for these 2 properties
				/**
				 * Unit for the measure, a pointer using the binding syntax to some field containing the unit.
				 * Value of the given field from the same data record will be displayed after formatted measure value in data label, tooltip and chart popover.
				 * NOTE: If the unit field is not set as visible dimension in chart, or more than one unit value exists
				 * for any visible dimension value combination, it will be rendered in the chart as well but with different layout when the field is set as visible dimension..
				 */
				unitBinding: {type: "string"},
				/**
				 * A (core UI5) format pattern to be used by the formatter to format the measure value.
				 * @deprecated
				 * Please use {@link sap.chart.Chart#setVizProperties} to set related formatStrings instead.
				 *
				 */
				valueFormat: {type: "string", defaultValue: null},
				/**
				 * How values of measure will be rendered in the chart. Possible role values are "axis1", "axis2", "axis3", and "axis4".
				 * The default is "axis1".
				 * They correspond to the well-known concepts of axis identifiers in the Cartesian coordinate system, e.g. a Y-axis in a bar/column/line chart, an X- and a Y-axis in a scatter chart, or two Y-axes in bar charts, and an optional third axis for the weight/size/intensity/temperature of a data point.
				 */
				role: {type: "string", defaultValue: "axis1"},
				/**
				 * The semantics of the measure.
				 */
				semantics: {type: "sap.chart.data.MeasureSemantics", defaultValue: MeasureSemantics.Actual},
				/**
				 * Semantically related measures for a measure with semantics "actual" value. It is an object with two properties:
				 * <ol>
				 *   <li>"projectedValueMeasure" identifing the projected value measure, and</li>
				 *   <li>"referenceValueMeasure" identifing the reference value measure.</li>
				 * </ol>
				 */
				semanticallyRelatedMeasures: {type: "object", defaultValue: null}
			}
		}
	});

	Measure.prototype.setLabel = ChartUtils.makeNotifyParentProperty("label");
	var roleSetter = ChartUtils.makeNotifyParentProperty("role");
	Measure.prototype.setRole = function(sValue, bSuppressInvalidate) {
		if (!_SUPPORTED_ROLE[sValue]) {
			jQuery.error("Invalide Measure role: " + sValue);
		}
		return roleSetter.apply(this, arguments);
	};
	Measure.prototype.setUnitBinding = ChartUtils.makeNotifyParentProperty("unitBinding");
	Measure.prototype.setValueFormat = ChartUtils.makeNotifyParentProperty("valueFormat");
	Measure.prototype.setSemantics = ChartUtils.makeNotifyParentProperty("semantics");
	Measure.prototype.setSemanticallyRelatedMeasures = ChartUtils.makeNotifyParentProperty("semanticallyRelatedMeasures");
	Measure.prototype._getFixedRole = function() {
		return this._sFixedRole || this.getRole();
	};
	return Measure;
});

}; // end of sap/chart/data/Measure.js
if ( !jQuery.sap.isDeclared('sap.chart.utils.DataSourceUtils') ) {
/*
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */
jQuery.sap.declare('sap.chart.utils.DataSourceUtils'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/utils/DataSourceUtils",[
	'sap/chart/data/Dimension',
	'sap/chart/data/TimeDimension',
	'sap/chart/data/Measure',
	'sap/chart/TimeUnitType'
], function(
	Dimension,
	TimeDimension,
	Measure,
	TimeUnitType
) {
	"use strict";

	function getEntitySet(bIsAnalytical, oBinding) {
		var sPath = oBinding.path;
		var sNamedEntitySet = (oBinding.parameters || {}).entitySet;
		if (!sNamedEntitySet) {
			// assume absolute path complying with conventions from OData4SAP spec
			sNamedEntitySet = sPath.split("/")[1];

			if (sNamedEntitySet.indexOf("(") != -1) {
				sNamedEntitySet = sNamedEntitySet.split("(")[0] + (bIsAnalytical ? "Results" : "Set");
			}
		}
		return sNamedEntitySet;
	}

	function _bindingSyntax(sResultType, sDimensionName, type) {
		return "{/#" + sResultType + "/" + sDimensionName + "/@sap:" + type + "}";
	}

	function detectDimension(oProps, oConfig) {
		//Fiscal timeUnits can be handled as well.  
		var Clazz = Dimension;
		if (oProps.type === "Edm.DateTime" && oProps['sap:display-format'] === "Date") {
			//TODO: sap:display-format is V2 annotation, use V4 style when annotation translation is ready
			Clazz = TimeDimension;
			oConfig.timeUnit = TimeUnitType.Date;
		} else if (oProps.type === "Edm.String" && TimeUnitType[oProps['sap:semantics']]) {
			//TODO: sap:semantics is V2 annotation, use V4 style when annotation translation is ready
			Clazz = TimeDimension;
			oConfig.timeUnit = oProps['sap:semantics'];
		}

		return Clazz;
	}

	var _ANALYTICAL = {
		getEntitySet: getEntitySet.bind(null, true),
		deriveColumns: function(oModel, oBindingInfo) {
			var oResult = oModel.getAnalyticalExtensions().findQueryResultByName(_ANALYTICAL.getEntitySet(oBindingInfo));
			if (!oResult) {
				throw new Error("value of the \"isAnalytical\" property does not match the Data Service in use");
			}
			var sResultType = oResult.getEntityType().getQName();
			sResultType = sResultType.slice(sResultType.lastIndexOf(".") + 1);
			var sResultSchemaNamespace = oResult.getEntityType().getSchema().namespace;

			var fnMakeDim = _ANALYTICAL.makeDimension.bind(this, sResultType, sResultSchemaNamespace, oResult);
			var fnMakeMsr = _ANALYTICAL.makeMeasure.bind(this, sResultType);

			return {
				dimensions: jQuery.map(oResult.getAllDimensions(), fnMakeDim),
				measures: jQuery.map(oResult.getAllMeasures(), fnMakeMsr)
			};
		},
		makeDimension: function(sResultType, sResultSchemaNamespace, oResult, oDimension) {
			var sDimName = oDimension.getName();
			var oConfig = {
				name: sDimName,
				label: _bindingSyntax(sResultType, sDimName, "label"),
				textProperty: _bindingSyntax(sResultType, sDimName, "text")
			};

			var sAnnotationAccess = _ANALYTICAL.ANNOTATION_ACCESS_TEMPLATE
					.replace(/%SCHEMANS/, sResultSchemaNamespace)
					.replace(/%RESULTTYPE/, sResultType)
					.replace(/%DIMENSION/, sDimName);

			var oUnifiedDimensionProperties = oResult.getModel().getODataModel().getMetaModel().getProperty(sAnnotationAccess);

			var Clazz = detectDimension(oUnifiedDimensionProperties, oConfig);

			return new Clazz(oConfig);
		},
		makeMeasure: function(sResultType, oMeasure) {
			return new Measure({
				name: oMeasure.getName(),
				label: _bindingSyntax(sResultType, oMeasure.getName(), "label")
			});
		},
		updateModel: function(oChart) {
			function createDimAnalyticalInfos(oDim, bInResult, bInVisible) {
				var sTextProperty = oDim.getTextProperty(),
					aInfos = [{ name: oDim.getName(), grouped: false, inResult: !!bInResult, visible: !bInVisible }];
				if (oDim.getDisplayText() && sTextProperty) {
					aInfos.push({ name: sTextProperty, grouped: false, inResult: !!bInResult, visible: !bInVisible });
				}
				return aInfos;
			}

			function createMsrAnalyticalInfos(oMsr) {
				var sUnitBinding = oMsr.getUnitBinding(),
					aInfos = [{ name: oMsr.getName(), total: false, inResult: false, visible: true }];
				if (sUnitBinding) {
					aInfos.push({ name: sUnitBinding, total: false, inResult: false, visible: true });
				}
				return aInfos;
			}

			var oBinding = oChart.getBinding("data");
			if (!oBinding) {
				return;
			}

			var aDims = oChart._getVisibleDimensions(true);
			var aMsrs = oChart._getVisibleMeasures(true);
			var aInResultDims = oChart._normalizeDorM(oChart.getInResultDimensions(), true);

			var aInfos = aDims.reduce(function(aInfos, oDim) {
				return aInfos.concat(createDimAnalyticalInfos(oDim));
			}, []).concat(aInResultDims.reduce(function(aInfos, oDim) {
				return aInfos.concat(createDimAnalyticalInfos(oDim, true, true));
			}, [])).concat(aMsrs.reduce(function(aInfos, oMsr) {
				return aInfos.concat(createMsrAnalyticalInfos(oMsr));
			}, []));

			var oCandidateColoringSetting = oChart._getCandidateColoringSetting();
			var oColoringAdditionalMsrs = oCandidateColoringSetting.additionalMeasures || [];
			var oColoringAdditionalDims = oCandidateColoringSetting.additionalDimensions || [];
			if (oColoringAdditionalMsrs.length) {
				aInfos = aInfos.concat(oChart._normalizeDorM(oColoringAdditionalMsrs).reduce(function(aInfo, oMsr) {
					return aInfo.concat(createMsrAnalyticalInfos(oMsr));
				}, []));
			}
			if (oColoringAdditionalDims.length) {
				aInfos = aInfos.concat(oChart._normalizeDorM(oColoringAdditionalDims, true).reduce(function(aInfo, oDim) {
					return aInfo.concat(createDimAnalyticalInfos(oDim));
				}, []));
			}

			oBinding.updateAnalyticalInfo(aInfos);
		},
		ANNOTATION_ACCESS_TEMPLATE: "/dataServices/schema/[${" +
			// ${xxx} will be interpolated by UI5 compiler, so we have to break all these annotations into separate strings
			"namespace" + "}==='%SCHEMANS']/entityType/[${" +
			"name" + "}==='%RESULTTYPE']/property/[${" +
			"name" + "}==='%DIMENSION']/"
	};

	var _NON_ANALYTICAL = {
		getEntitySet: getEntitySet.bind(null, false),
		deriveColumns: function(oModel, oBindingInfo) {
			var oMetaModel = oModel.getMetaModel(),
				mColumns = {dimensions: [], measures: []};
			if (oMetaModel) {
				var sQNameEntityType = oMetaModel.getODataEntitySet(_NON_ANALYTICAL.getEntitySet(oBindingInfo)).entityType;
				var oEntityType = oMetaModel.getODataEntityType(sQNameEntityType);

				jQuery.each(oEntityType.property, function(i, oProp) {
					var ColumnClazz = _NON_ANALYTICAL.CLAZZ[oProp.type];
					if (!ColumnClazz) {
						throw new Error("Unsupported type: " + oProp.type);
					}
					var oConfig = { name: oProp.name };
					if (oProp.hasOwnProperty("sap:label")) {
						oConfig.label = oProp["sap:label"];
					}

					if (ColumnClazz === Measure) {
						mColumns.measures.push(new ColumnClazz(oConfig));
					} else {
						if (oProp.hasOwnProperty("sap:text")) {
							oConfig.textProperty = oProp["sap:text"];
						}

						ColumnClazz = detectDimension(oProp, oConfig);
						mColumns.dimensions.push(new ColumnClazz(oConfig));
					}
				});
			}

			return mColumns;
		},
		CLAZZ: {
			"Null": Dimension,
			"Edm.Binary": Dimension,
			"Edm.Boolean": Dimension,
			"Edm.Byte": Measure,
			"Edm.DateTime": Dimension,
			"Edm.Decimal": Measure,
			"Edm.Double": Measure,
			"Edm.Single": Measure,
			"Edm.Guid": Dimension,
			"Edm.Int16": Measure,
			"Edm.Int32": Measure,
			"Edm.Int64": Measure,
			"Edm.SByte": Measure,
			"Edm.String": Dimension,
			"Edm.Time": Dimension,
			"Edm.DateTimeOffset": Dimension
		},
		updateModel: function(oChart, aDimensions, aMeasures) {
			if (oChart.getModel() instanceof sap.ui.model.odata.ODataModel) {
				var oBindingInfo = oChart.getBindingInfo("data");
				var aDimColumns = aDimensions.reduce(function(aDimColumns, oDim) {
					if (oDim.getTextProperty()) {
						return aDimColumns.concat(oDim.getName(), oDim.getTextProperty());
					} else {
						return aDimColumns.concat(oDim.getName());
					}
				}, []);
				var aMsrColumns = aMeasures.reduce(function(aMsrColumns, oMsr) {
					if (oMsr.getUnitBinding()) {
						return aMsrColumns.concat(oMsr.getName(), oMsr.getUnitBinding());
					} else {
						return aMsrColumns.concat(oMsr.getName());
					}
				}, []);
				oChart.bindData({
					path: oBindingInfo.path,
					parameters: {
						entitySet: _NON_ANALYTICAL.getEntitySet(oBindingInfo),
						select: aDimColumns.concat(aMsrColumns).join(",")
					}
				});
			} else {
				return;
			}
		}
	};

	function impl(methodName) {
		return function(bIsAnalytical) {
			var implementation = bIsAnalytical ? _ANALYTICAL : _NON_ANALYTICAL;
			return implementation[methodName];
		};
	}

	return {
		deriveColumns: impl("deriveColumns"),
		updateModel: impl("updateModel"),
		getEntitySet: impl("getEntitySet")
	};
});

}; // end of sap/chart/utils/DataSourceUtils.js
if ( !jQuery.sap.isDeclared('sap.chart.coloring.criticality.measureValues.MeasureUtils') ) {
jQuery.sap.declare('sap.chart.coloring.criticality.measureValues.MeasureUtils'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/coloring/criticality/measureValues/MeasureUtils",[
	'sap/chart/coloring/ColoringUtils',
	'sap/chart/coloring/criticality/measureValues/ThresholdsUtils',
	'sap/chart/ChartLog',
	'sap/chart/library'
], function(
	ColoringUtils,
	ThresholdsUtils,
	ChartLog,
	chartLibrary
) {
	"use strict";
	var type = jQuery.type;
	var CriticalityType = chartLibrary.coloring.CriticalityType;
	var mathSymbol = {
		ge: "\u2265", //>=
		lt: "<",
		le: "\u2264", //<=
		gt: ">"
	};

	var Msr = {
		Static: {},
		Calculated: {},
		DynamicThresholds: {},
		ConstantThresholds: {},
		Unmentioned: {}
	};

	Msr.Static.parse = function(oConfig, options, oParsed) {
		var sMsr = oConfig.msr ? oConfig.msr.getName() : undefined;
		var sStaticProperty = oConfig.settings[oConfig.type];
		oParsed.callbacks = Msr.Static.getCallbacks(sStaticProperty, sMsr);
		var oDefaultLegend = oConfig.msr.getLabel() || oConfig.msr.getName();
		var oCustomLegend = oConfig.settings.Legend || {};
		oParsed.legend[sStaticProperty] =  (oCustomLegend[sStaticProperty] != null) ? oCustomLegend[sStaticProperty] : oDefaultLegend;
	};

	Msr.Static.getCallbacks = function(sCriticalityType, sMsr) {
		var cb = {};
		cb[sCriticalityType] = [function(oCtx) {
			return oCtx.hasOwnProperty(sMsr);
		}];
		return cb;
	};

	Msr.Calculated.parse = function(oConfig, options, oParsed, bMBC) {
		var sCalculatedProperty = oConfig.settings[oConfig.type];
		if (!ColoringUtils.find(sCalculatedProperty, options.aDims)) {
			oParsed.additionalDimensions.push(sCalculatedProperty);
		}
		oParsed.status = options.oStatus;
	};

	Msr.Calculated.getCallbacks = function(sPropName, sCriticalityType, sMsr) {
		var cb = function(oCtx) {
			return (oCtx[sPropName] === sCriticalityType) && oCtx.hasOwnProperty(sMsr);
		};
		return [cb];
	};

	Msr.Calculated.getContextHandler = function(aCandidateSettings, bMBC, oLocale) {
		var oCandidate = aCandidateSettings[0];
		var sCalculatedProperty = oCandidate.settings[oCandidate.type];
		return function(oContext) {
			var oStatus = oCandidate.parsed.status;
			oStatus.legend = oStatus.legend || {};
			oStatus.callbacks = oStatus.callbacks || {};
			oCandidate.parsed.legend = oStatus.legend;
			oCandidate.parsed.callbacks = oStatus.callbacks;

			var sCriticalityType = oContext.getProperty(sCalculatedProperty);
			var oCalculatedProperty = this.getDimensionByName(sCalculatedProperty);
			var bDisplayText = this.getDimensionByName(sCalculatedProperty).getDisplayText();

			aCandidateSettings.legendTitle = aCandidateSettings.legendTitle || oCalculatedProperty.getLabel();
			if (!oCalculatedProperty) {
				//clid11
				throw new ChartLog('error', 'Colorings.Criticality.Calculated', 'Calculated property does not exist in data model');
			}
			var sCalculatedTextProperty = oCalculatedProperty.getTextProperty();
			if (sCalculatedTextProperty && bDisplayText) {
				var sCriticalityTypeText = oContext.getProperty(sCalculatedTextProperty);
				oCandidate.parsed.legend[sCriticalityType] = sCriticalityTypeText;
			} else if (sCriticalityType) {
				oCandidate.parsed.legend[sCriticalityType] = oLocale.getText("COLORING_TYPE_" + sCriticalityType.toUpperCase());
			}
			var sMsr = oCandidate.msr.getName();
			var cb = Msr.Calculated.getCallbacks(sCalculatedProperty, sCriticalityType, sMsr);
			oCandidate.parsed.callbacks[sCriticalityType] = cb;
		};
	};

	Msr.DynamicThresholds.parse = function(oConfig, options, oParsed, bMBC, oLocale) {
		var oSetting = oConfig.settings[oConfig.type];
		var sMsr = oConfig.msr ? oConfig.msr.getName() : undefined;
		var sDir = oSetting.ImprovementDirection.toLowerCase();
		var oTolRange = {
			lo: oSetting.ToleranceRangeLowValue,
			hi: oSetting.ToleranceRangeHighValue
		};
		var oDevRange = {
			lo: oSetting.DeviationRangeLowValue,
			hi: oSetting.DeviationRangeHighValue
		};
		checkThresholds(sDir, oTolRange, oDevRange);

		var oBreakdown = {};
		if (oSetting.Breakdown) {
			oBreakdown.NegativeLevels = oSetting.Breakdown.NegativeLevels;
			oBreakdown.CriticalLevels = oSetting.Breakdown.CriticalLevels;
			oBreakdown.PositiveLevels = oSetting.Breakdown.PositiveLevels;
			oBreakdown.MinimumMeasureValue = oSetting.Breakdown.MinimumMeasureValue;
			oBreakdown.MaximumMeasureValue = oSetting.Breakdown.MaximumMeasureValue;
		}

		oParsed.callbacks = ThresholdsUtils.improvement(sDir, sMsr, oTolRange, oDevRange, oBreakdown);
		oParsed.additionalMeasures = [oTolRange.lo, oTolRange.hi, oDevRange.lo, oDevRange.hi, oBreakdown.MinimumMeasureValue, oBreakdown.MaximumMeasureValue].filter(function(val) {
			return type(val) === 'string';
		});
		var oDefaultLegend = {};
		jQuery.each(CriticalityType, function(key, value) {
			oDefaultLegend[value] = oLocale.getText("COLORING_TYPE_" + value.toUpperCase());
		});
		oParsed.legend = jQuery.extend(true, {}, oDefaultLegend, oConfig.settings.Legend);
	};

	function checkThresholds(sDir, oTolRange, oDevRange, bConstant) {
		var bExist, bRange;
		switch (sDir) {
			case 'maximize':
				bExist = oDevRange.lo != undefined && oTolRange.lo != undefined;
				bRange = (ColoringUtils.isNumber(oDevRange.lo, oTolRange.lo) && (oDevRange.lo < oTolRange.lo));
				break;
			case 'minimize':
				bExist = oTolRange.hi != undefined && oDevRange.hi != undefined;
				bRange = (ColoringUtils.isNumber(oTolRange.hi, oDevRange.hi) && (oTolRange.hi < oDevRange.hi));
				break;
			case 'target':
				bExist = oDevRange.lo != undefined && oTolRange.lo != undefined && oTolRange.hi != undefined && oDevRange.hi != undefined;
				bRange = (ColoringUtils.isNumber(oDevRange.lo, oTolRange.lo, oTolRange.hi, oDevRange.hi) && 
					(oDevRange.lo < oTolRange.lo) && (oTolRange.lo < oTolRange.hi) && (oTolRange.hi < oDevRange.hi));
				break;
			default:
		}
		if (!bExist || (bConstant && !bRange)) {
			//clid17, clid20
			var sThresholds = bConstant ? "ConstantThresholds" : "DynamicThresholds";
			throw new ChartLog('error', 'Colorings.Criticality.' + sThresholds, 'Invalid Thresholds settings');
		}
	}

	Msr.ConstantThresholds.parse = function(oConfig, options, oParsed, bMBC) {
		var oSetting = oConfig.settings[oConfig.type];
		var sMsr = oConfig.msr ? oConfig.msr.getName() : undefined;
		var sDir = oSetting.ImprovementDirection.toLowerCase();
		var oTolRange = {
			lo: oConfig.byAggregation.ToleranceRangeLowValue,
			hi: oConfig.byAggregation.ToleranceRangeHighValue
		};
		var oDevRange = {
			lo: oConfig.byAggregation.DeviationRangeLowValue,
			hi: oConfig.byAggregation.DeviationRangeHighValue
		};
		checkThresholds(sDir, oTolRange, oDevRange, true);

		var oBreakdown = {};
		if (oSetting.Breakdown) {
			oBreakdown.NegativeLevels = oSetting.Breakdown.NegativeLevels;
			oBreakdown.CriticalLevels = oSetting.Breakdown.CriticalLevels;
			oBreakdown.PositiveLevels = oSetting.Breakdown.PositiveLevels;
			oBreakdown.MinimumMeasureValue = oConfig.byAggregation.Breakdown.MinimumMeasureValue;
			oBreakdown.MaximumMeasureValue = oConfig.byAggregation.Breakdown.MaximumMeasureValue;
		}

		if (bMBC) {
			oParsed.legend = ThresholdsUtils.MBCimprovement(sDir, oTolRange, oDevRange);
		} else {
			oParsed.callbacks = ThresholdsUtils.improvement(sDir, sMsr, oTolRange, oDevRange, oBreakdown);
			oParsed.additionalMeasures = [oTolRange.lo, oTolRange.hi, oDevRange.lo, oDevRange.hi, oBreakdown.MinimumMeasureValue, oBreakdown.MaximumMeasureValue].filter(function(val) {
				return type(val) === 'string';
			});
			oParsed.legend = Msr.ConstantThresholds.getLegend(sDir, sMsr, oTolRange, oDevRange);
		}
	};

	Msr.ConstantThresholds.getLegend = function(sDir, sMsr, oTolRange, oDevRange) {
		var oLegend = {};

		var maximizePositive = sMsr + ' ' + mathSymbol.ge + ' ' + oTolRange.lo;
		var maximizeCritical = oDevRange.lo + ' ' + mathSymbol.le + ' ' + sMsr + ' ' + mathSymbol.lt + ' ' + oTolRange.lo;
		var maximizeNegative = sMsr + ' ' + mathSymbol.lt + ' ' + oDevRange.lo;

		var minimizePositive = sMsr + ' ' + mathSymbol.le + ' ' + oTolRange.hi;
		var minimizeCritical = oTolRange.hi + ' ' + mathSymbol.lt + ' ' + sMsr + ' ' + mathSymbol.le + ' ' + oDevRange.hi;
		var minimizeNegative = sMsr + ' ' + mathSymbol.gt + ' ' + oDevRange.hi;

		switch (sDir) {
			case 'maximize':
				oLegend = {
					Positive: maximizePositive,
					Critical: maximizeCritical,
					Negative: maximizeNegative
				};
				break;
			case 'minimize':
				oLegend = {
					Positive: minimizePositive,
					Critical: minimizeCritical,
					Negative: minimizeNegative
				};
				break;
			case 'target':
				oLegend = {
					Positive: oTolRange.lo + ' ' + mathSymbol.le + ' ' + sMsr + ' ' + mathSymbol.le + ' ' + oTolRange.hi,
					Critical: maximizeCritical + ' , ' + minimizeCritical,
					Negative: maximizeNegative + ' , ' + minimizeNegative
				};
				break;	
			default:
		}
		return oLegend;
	};

	Msr.ConstantThresholds.getContextHandler = function(aCandidateSettings, bMBC) {
		if (bMBC) {
			var oCandidate = aCandidateSettings[0];
			var sMsr = oCandidate.msr.getName();
			var oLegend = oCandidate.parsed.legend;
			return function(oContext) {
				var iVal = oContext.getProperty(sMsr);
				oLegend.min = Math.min(oLegend.min, iVal);
				oLegend.max = Math.max(oLegend.max, iVal);
			};
		} else {
			return null;
		}
	};

	Msr.Unmentioned.getCallbacks = function(aMsrs) {
		var cb = {
			'Unmentioned': aMsrs.map(function(oMsr) {
				return function(oCtx) {
					return oCtx.hasOwnProperty(oMsr.getName());
				};
			})
		};
		return cb;
	};

	Msr.Unmentioned.parse = function(oConfig, options, oParsed) {
		oParsed.callbacks = Msr.Unmentioned.getCallbacks(oConfig.settings);
		oParsed.legend = oConfig.settings.map(function(oMsr) {
			return oMsr.getLabel() || oMsr.getName();
		});
	};

	return Msr;
});
}; // end of sap/chart/coloring/criticality/measureValues/MeasureUtils.js
if ( !jQuery.sap.isDeclared('sap.chart.coloring.criticality.measureValues.MeasureValues') ) {
jQuery.sap.declare('sap.chart.coloring.criticality.measureValues.MeasureValues'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/coloring/criticality/measureValues/MeasureValues",[
	'sap/chart/coloring/ColoringUtils',
	'sap/chart/coloring/ColorPalette',
	'sap/chart/coloring/criticality/measureValues/MeasureUtils',
	'sap/chart/ChartLog'
], function(
	ColoringUtils,
	ColorPalette,
	MeasureUtils,
	ChartLog
) {
	"use strict";
	var type = jQuery.type;
	var MeasureValues = {};

	MeasureValues.validate = function(aConfigs, aMsrs, aDims, aActiveMsrs) {
		if (aActiveMsrs.length > 1) {
			// Multiple measures with Static method
			var oCriticalityType = {};
			aConfigs.forEach(function(oConfig) {
				if (oConfig.type === "Static") {
					var sStatic = oConfig.settings.Static;
					if (oCriticalityType[sStatic]) {
						//clid4
						throw new ChartLog('error', 'Colorings.Criticality.Static', 'Measures using Static method must have different Criticality Type');
					} else {
						oCriticalityType[sStatic] = true;
					}
				} else {
					//clid5
					throw new ChartLog('error', 'Colorings.Criticality', 'Only support multiple active measures using Static method');
				}
			});
		} else if (aActiveMsrs.length < 1) {
			// activeColoring is not defined
			if (aConfigs.length > 1) {
				//clid6
				throw new ChartLog('error', 'Colorings.Criticality.MeasureValues', 'Multiple measures are defined, please resolve by activeColoring property');
			}
		}
	};

	MeasureValues.qualify = function(oConfig, aMsrs, aDims, oStatus, oActiveColoring, options) {
		var aCandidateConfigs = [];
		var sAggregationKey = aDims.map(function(oDim) {
			return oDim.getName();
		}).sort().join(",");
		var aMentionedMsrs = [];
		var aActiveMsrs = [];

		if (oActiveColoring && oActiveColoring.parameters && oActiveColoring.parameters.measure) {
			aActiveMsrs = (type(oActiveColoring.parameters.measure) === "array") ? 
			oActiveColoring.parameters.measure : [oActiveColoring.parameters.measure];
			var bActiveMsrVisible = aActiveMsrs.every(function(sMsr) {
				return ColoringUtils.find(sMsr, aMsrs);
			});
			if (!bActiveMsrVisible) {
				//clid7
				throw new ChartLog('error', 'Colorings', 'Active Dimensions/Measures should be visible');
			}
		}

		jQuery.each(oConfig, function(sMeasureName, oSetting) {
			var aSettingKeys = Object.keys(oSetting);
			var oMatchedMsr = ColoringUtils.find(sMeasureName, aMsrs);
			var aExcludeLegend = aSettingKeys.filter(function(key) {
				return key !== "Legend";
			});

			if (aActiveMsrs.length && aActiveMsrs.indexOf(sMeasureName) === -1) {
				// filter inactive config
				return;
			}
			if (aExcludeLegend.length !== 1) {
				//clid8
				throw new ChartLog('error', 'Colorings.Criticality.MeasureValues', 'One and only one of "Static", "Calculated", "DynamicThresholds", or "ConstantThresholds" is required');
			}
			if (!oMatchedMsr) {
				return;
			}

			var sKey = aExcludeLegend[0];
			aCandidateConfigs.sMethod = sKey;

			if (sKey === "ConstantThresholds") {
				var oMatchedByAggregation = null;
				for (var i = 0; i < oSetting[sKey].AggregationLevels.length; i++) {
					var sAggKeyToTest = oSetting[sKey].AggregationLevels[i].VisibleDimensions.sort().join(",");
					if (sAggKeyToTest === sAggregationKey) {
						oMatchedByAggregation = oSetting[sKey].AggregationLevels[i];
						break;
					}
				}

				if (oMatchedByAggregation) {
					aCandidateConfigs.push({
						type: sKey,
						msr: oMatchedMsr,
						settings: oSetting,
						byAggregation: oMatchedByAggregation
					});
					aMentionedMsrs.push(oMatchedMsr.getName());
				}

			} else {
				aCandidateConfigs.push({
					type: sKey,
					msr: oMatchedMsr,
					settings: oSetting
				});
				aMentionedMsrs.push(oMatchedMsr.getName());
			}
		});
	    
		if (aCandidateConfigs.length) {
			MeasureValues.validate(aCandidateConfigs, aMsrs, aDims, aActiveMsrs);
			if (options.bMBC && aCandidateConfigs[0].type != "ConstantThresholds") {
				//clid23
				throw new ChartLog('error', 'Colorings', 'Heatmap only support Criticality.MeasureValues.ConstantThresholds');
			}
			if (options.bShowUnmentionedMsr) {
				var aUnmentionedMsrs = aMsrs.filter(function(oMsr) {
					return aMentionedMsrs.indexOf(oMsr.getName()) === -1;
				});
				if (aUnmentionedMsrs.length && aUnmentionedMsrs.length <= 5) {
					aCandidateConfigs.push({
						type: "Unmentioned",
						settings: aUnmentionedMsrs
					});
				} else if (aUnmentionedMsrs.length > 5) {
					//clid18
					throw new ChartLog("warning", 'Colorings.Criticality.MeasureValues', "Too many unmentioned measures (the maximum number is 5)");
				}
			}

		}

		return aCandidateConfigs;
	};

	MeasureValues.parse = function(oConfig, aMsrs, aDims, aInResultDims, oStatus, oOptions, oLocale) {
		var bMBC = oOptions.bMBC;
		var bIsPie = oOptions.bIsPie;
		var options = {
			aMsrs: aMsrs,
			aDims: aDims,
			oStatus: oStatus
		};
		var oParsed = {
			msr: oConfig.msr,
			callbacks: {},
			additionalMeasures: [],
			additionalDimensions: [],
			legend: {}
		};
		
		if (aInResultDims.length) {
			//clid9
			throw new ChartLog('error', 'colorings.Criticality.MeasureValues', 'Semantic coloring could not be applied if inResult Dimensions exist');
		}

		var bHasSeriesDim = aDims.some(function(oDim) {
			return oDim._getFixedRole() === "series";
		});
		if (bHasSeriesDim || (bIsPie && aDims.length)) {
			// Dimensions of Pie(donut) will automatically map to color feeding
			//clid10
			throw new ChartLog('error', 'colorings.Criticality.MeasureValues', 'Semantic coloring could not be applied if chart already has coloring');
		}

		MeasureUtils[oConfig.type].parse(oConfig, options, oParsed, bMBC, oLocale);
		return oParsed;
	};

	MeasureValues.getContextHandler = function(sCriticalityMethod, aCandidateSettings, bMBC, oLocale) {
		if (MeasureUtils[sCriticalityMethod].getContextHandler) {
			return MeasureUtils[sCriticalityMethod].getContextHandler(aCandidateSettings, bMBC, oLocale);
		} else {
			return null;
		}
	};

	return MeasureValues;
});
}; // end of sap/chart/coloring/criticality/measureValues/MeasureValues.js
if ( !jQuery.sap.isDeclared('sap.chart.coloring.criticality.Criticality') ) {
/*
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.chart.coloring.criticality.Criticality'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/coloring/criticality/Criticality",[
	'sap/chart/coloring/criticality/measureValues/MeasureValues',
	'sap/chart/coloring/criticality/DimensionValues',
	'sap/chart/coloring/ColoringUtils',
	'sap/chart/coloring/ColorPalette',
	'sap/chart/ChartLog',
	'sap/chart/library'
], function(
	MeasureValues,
	DimensionValues,
	ColoringUtils,
	ColorPalette,
	ChartLog,
	chartLibrary
) {
	"use strict";
	var type = jQuery.type;
	var SUPPORTED_TYPES = ['DimensionValues', 'MeasureValues'];
	var CriticalityType = chartLibrary.coloring.CriticalityType;
	var aMeasureLegendOrder = [
		CriticalityType.Positive,
		CriticalityType.Neutral,
		CriticalityType.Critical,
		CriticalityType.Negative,
		'Unmentioned'
	];
	var aDimensionLegendOrder = [
		CriticalityType.Positive,
		CriticalityType.Critical,
		CriticalityType.Negative,
		CriticalityType.Neutral
	];

	function use(oColorings, oActiveCriticalityColoring) {
		var oParams = oActiveCriticalityColoring ? oActiveCriticalityColoring.parameters : {};
		var types = Object.keys(oColorings).filter(function(sType) {
			return !SUPPORTED_TYPES.indexOf(sType) !== -1;
		});

		if (oParams && oParams.dimension && oParams.measure) {
			//clid3
			throw new ChartLog('error', 'colorings.Criticality', 'Both "DimensionValues" and "MeasureValues" present in coloring CRITICALITY, activeColoring.parameters is required to specify which to use');
		} else if (oParams && oParams.dimension) {
			return 'DimensionValues';
		} else if (oParams && oParams.measure) {
			return 'MeasureValues';
		} else if (types.length === 1) {
			return types[0];
		} else {
			return null;
		}
	}

	function createRules(aCandidateSettings, aLegendOrder) {
		var aRules = [];
		aLegendOrder.forEach(function(sCriticalityType) {
			aCandidateSettings.forEach(function(oCandidateSetting) {
				if (oCandidateSetting.chartLog) {
					throw oCandidateSetting.chartLog;
				}
				var aCbs = oCandidateSetting.parsed.callbacks[sCriticalityType] || [];
				aCbs.forEach(function(fnCb, idx) {
					var aColors, sDisplayName;
					if (sCriticalityType === "Unmentioned") {
						aColors = ColoringUtils.assignUnmentionedColor(ColorPalette.CRITICALITY.Neutral, aCbs.length);
						sDisplayName = oCandidateSetting.parsed.legend[idx];
					} else {
						aColors = ColoringUtils.assignColor(ColorPalette.CRITICALITY[sCriticalityType], aCbs.length);
						var oLegend = oCandidateSetting.parsed.legend[sCriticalityType];
						sDisplayName = (type(oLegend) === "array") ? oLegend[idx] : oLegend;
					}
					aRules.push({
						callback: fnCb,
						properties: {
							color: aColors[idx]
						},
						displayName: sDisplayName
					});
				});
			});
		});
		return aRules;
	}

	function createScales(aCandidateSettings) {
		var oCandidate = aCandidateSettings[0];
		var oLegend = oCandidate.parsed.legend;
		
		var aPalettes = [], aBoundaries = [];
		var bNeedMin = (oLegend.segments[0].upperBound > oLegend.min) ? true : false;
		var bNeedMax = (oLegend.segments[oLegend.segments.length - 2].upperBound < oLegend.max) ? true : false;

		oLegend.segments.forEach(function(oSegment) {
			var aColors = ColoringUtils.assignColor(ColorPalette.CRITICALITY[oSegment.CriticalityType], 1);
			aPalettes.push(aColors[0]);
			aBoundaries.push(oSegment.upperBound);
		});

		if (bNeedMin) {
			aBoundaries = [oLegend.min].concat(aBoundaries);
		} else {
			aPalettes.splice(0, 1);
		}

		if (bNeedMax) {
			aBoundaries[aBoundaries.length - 1] = oLegend.max;
		} else {
			aPalettes.splice(aPalettes.length - 1, 1);
			aBoundaries.splice(aBoundaries.length - 1, 1);
		}
		
		if (aPalettes.length <= 1) {
			//cvom does not natively support one segment case in mbc legend
			return null;
		}

		return {
			feed: "color",
			palette: aPalettes,
			numOfSegments: aPalettes.length,
			legendValues: aBoundaries
		};
	}

	function getLegendProps(aCandidateSettings) {
		var oLegendProps;
		if (aCandidateSettings.legendTitle) {
			oLegendProps = {
				title: {
					text: aCandidateSettings.legendTitle,
					visible: true
				}
			};
		} else {
			oLegendProps = {
				title: {
					text: null,
					visible: false
				}
			};
		}
		return oLegendProps;
	}

	function getRuleGenerator(aCandidateSettings, aLegendOrder) {
		return function() {
			var colorScale, properties;
			if (aCandidateSettings.bMBC) {
				colorScale = createScales(aCandidateSettings);
			} else {
				var rules = createRules(aCandidateSettings, aLegendOrder);
				properties = {
					plotArea: {
						dataPointStyle: {
							rules: rules
						}
					},
					legend: getLegendProps(aCandidateSettings)
				};
			}
			return {
				colorScale: colorScale,
				properties: properties
			};
		};
	}

	return {
		getCandidateSetting: function(oColorings, oActiveColoring, aMsr, aDim, aInResultDims, oStatus, options, oLocale) {
			var bMBC = options.bMBC;
			var oCriticality = oColorings.Criticality || {};
			var sUseType = use(oCriticality, oActiveColoring);
			var oCandidateSetting = {
				additionalMeasures: [],
				additionalDimensions: []
			};
			var aQualifiedSettings, oParsed, sCriticalityMethod;

			switch (sUseType) {
				case 'DimensionValues':
					aQualifiedSettings = DimensionValues.qualify(oCriticality.DimensionValues, aMsr, aDim, aInResultDims, oActiveColoring, "Criticality", options);
					if (aQualifiedSettings) {
						aQualifiedSettings.parsed = DimensionValues.parse(aQualifiedSettings, aDim, oStatus, oLocale, options);
						oCandidateSetting.contextHandler = DimensionValues.getContextHandler(aQualifiedSettings, oLocale);
						oCandidateSetting.ruleGenerator = getRuleGenerator([aQualifiedSettings], aDimensionLegendOrder);
					}
					break;
				case 'MeasureValues':
					aQualifiedSettings = MeasureValues.qualify(oCriticality.MeasureValues, aMsr, aDim, oStatus, oActiveColoring, options);
					if (aQualifiedSettings.sMethod) {
						jQuery.each(aQualifiedSettings, function(i, oQualified) {
							oParsed = MeasureValues.parse(oQualified, aMsr, aDim, aInResultDims, oStatus, options, oLocale);
							jQuery.each(oParsed.additionalMeasures, function(i, sThresholdMsrName) {
								oCandidateSetting.additionalMeasures[sThresholdMsrName] = true;
							});
							jQuery.each(oParsed.additionalDimensions, function(i, sCalculatedName) {
								oCandidateSetting.additionalDimensions[sCalculatedName] = true;
							});
							oQualified.parsed = oParsed;
							if (oQualified.settings.Legend && oQualified.settings.Legend.Title) {
								aQualifiedSettings.legendTitle = oQualified.settings.Legend.Title;
							}
						});
						sCriticalityMethod = aQualifiedSettings.sMethod;
						oCandidateSetting.additionalMeasures = Object.keys(oCandidateSetting.additionalMeasures);
						oCandidateSetting.additionalDimensions = Object.keys(oCandidateSetting.additionalDimensions);
						oCandidateSetting.contextHandler = MeasureValues.getContextHandler(sCriticalityMethod, aQualifiedSettings, bMBC, oLocale);
						oCandidateSetting.ruleGenerator = getRuleGenerator(aQualifiedSettings, aMeasureLegendOrder);
						aQualifiedSettings.bMBC = bMBC;
					}
					break;
				default:
					return {};
			}

			return oCandidateSetting;
		}
	};
});

}; // end of sap/chart/coloring/criticality/Criticality.js
if ( !jQuery.sap.isDeclared('sap.chart.coloring.Colorings') ) {
/*
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */

jQuery.sap.declare('sap.chart.coloring.Colorings'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
sap.ui.define("sap/chart/coloring/Colorings",[
	"sap/chart/coloring/criticality/Criticality",
	"sap/chart/coloring/emphasis/Emphasis",
	'sap/chart/ChartLog'
], function(
	Criticality,
	Emphasis,
	ChartLog
) {
	"use strict";

	var SUPPORTED_TYPES = ['Criticality', 'Emphasis'];
	function use(oColorings, oActiveColoring) {
		var use = null;
		var sColoring = oActiveColoring ? oActiveColoring.coloring : null;
		var oParams = oActiveColoring ? oActiveColoring.parameters : null;

		if (oParams && oParams.dimension && oParams.measure) {
			//clid1
			throw new ChartLog('error', 'activeColoring', "Either \"dimension\" or \"measure\" can be set in activeColoring.parameters, but not both of them");
		}

		if (SUPPORTED_TYPES.indexOf(sColoring) > -1) {
			use = sColoring;
		}

		return use;
	}

	return {
		getCandidateSetting: function(oColorings, oActiveColoring, aMsrs, aDims, aInResultDims, oStatus, sChartType, oLocale) {
			var useColoringType = use(oColorings, oActiveColoring);
			var coloringClz, options = {};
			options.bMBC = (sChartType === "heatmap") ? true : false;
			options.bShowUnmentionedMsr = (sChartType === "scatter" || sChartType === "bubble") ? false : true;
			options.bIsPie = (sChartType === "pie" || sChartType === "donut") ? true : false;
			options.chartType = sChartType;
			switch (useColoringType) {
				case 'Criticality':
					coloringClz = Criticality;
					break;
				case 'Emphasis':
					coloringClz = Emphasis;
					break;
				default:
					coloringClz = null;
					break;
			}
			if (coloringClz) {
				return coloringClz.getCandidateSetting(oColorings, oActiveColoring, aMsrs, aDims, aInResultDims, oStatus, options, oLocale);
			} else {
				return {};
			}
		}
	};
});
}; // end of sap/chart/coloring/Colorings.js
if ( !jQuery.sap.isDeclared('sap.chart.Chart') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2009-2017 SAP SE. All rights reserved
 */
jQuery.sap.declare('sap.chart.Chart'); // unresolved dependency added by SAPUI5 'AllInOne' Builder
jQuery.sap.require('sap.viz.ui5.controls.VizFrame'); // unlisted dependency retained
jQuery.sap.require('sap.viz.ui5.controls.common.BaseControl'); // unlisted dependency retained
jQuery.sap.require('sap.viz.ui5.data.Dataset'); // unlisted dependency retained
jQuery.sap.require('sap.viz.ui5.data.FlattenedDataset'); // unlisted dependency retained
jQuery.sap.require('sap.viz.ui5.data.DimensionDefinition'); // unlisted dependency retained
jQuery.sap.require('sap.viz.ui5.data.MeasureDefinition'); // unlisted dependency retained
jQuery.sap.require('sap.ui.model.analytics.ODataModelAdapter'); // unlisted dependency retained
jQuery.sap.require('sap.viz.ui5.controls.common.feeds.FeedItem'); // unlisted dependency retained
jQuery.sap.require('sap.ui.model.Filter'); // unlisted dependency retained
jQuery.sap.require('sap.ui.model.FilterOperator'); // unlisted dependency retained
jQuery.sap.require('sap.ui.model.analytics.odata4analytics'); // unlisted dependency retained
jQuery.sap.require('sap.ui.model.Sorter'); // unlisted dependency retained
sap.ui.define("sap/chart/Chart",[
	'sap/chart/library',
	'sap/viz/ui5/controls/VizFrame',
	'sap/viz/ui5/controls/common/BaseControl',
	'sap/viz/ui5/data/Dataset',
	'sap/viz/ui5/data/FlattenedDataset',
	'sap/viz/ui5/data/DimensionDefinition',
	'sap/viz/ui5/data/MeasureDefinition',
	'sap/chart/data/Dimension',
	'sap/chart/data/TimeDimension',
	'sap/chart/data/Measure',
	'sap/ui/model/analytics/ODataModelAdapter',
	'sap/chart/utils/RoleFitter',
	'sap/chart/utils/ChartUtils',
	'sap/chart/utils/SeriesColorTracker',
	'sap/chart/utils/ChartTypeAdapterUtils',
	'sap/chart/utils/DateFormatUtil',
	'sap/chart/utils/DataSourceUtils',
	'sap/chart/utils/SelectionAPIUtils',
	'sap/chart/utils/MeasureSemantics',
	'sap/viz/ui5/controls/common/feeds/FeedItem',
	'sap/ui/model/Filter',
	'sap/ui/model/FilterOperator',
	'sap/ui/model/analytics/odata4analytics',
	'sap/ui/model/Sorter',
	'sap/chart/TimeUnitType',
	'sap/chart/coloring/Colorings',
	'sap/chart/ChartLog'
], function(
	library,
	VizFrame,
	BaseControl,
	Dataset,
	FlattenedDataset,
	DimensionDefinition,
	MeasureDefinition,
	Dimension,
	TimeDimension,
	Measure,
	ODataModelAdapter,
	RoleFitter,
	ChartUtils,
	SeriesColorTracker,
	ChartTypeAdapterUtils,
	DateFormatUtil,
	DataSourceUtils,
	SelectionAPIUtils,
	MeasureSemanticsUtils,
	FeedItem,
	Filter,
	FilterOperator,
	odata4analytics,
	Sorter,
	TimeUnitType,
	Colorings,
	ChartLog
) {
	"use strict";

	var SelectionMode = sap.chart.SelectionMode;

	/**
	 * Constructor for a new Chart.
	 *
	 * @param {string} [sId] id for the new control, generated automatically if no id is given
	 * @param {object} [mSettings] initial settings for the new control
	 *
	 * @class
	 * UI5 Chart control
	 *
	 * @extends sap.viz.ui5.controls.common.BaseControl
	 *
	 * @constructor
	 * @public
	 * @since 1.32.0
	 * @alias sap.chart.Chart
	 */
	var Chart = BaseControl.extend("sap.chart.Chart", {
		metadata: {
			library: "sap.chart",
			properties: {
				/**
				 * Type of the Chart.
				 *
				 */
				chartType						: {type: "string", defaultValue: "bar"},
				/**
				 * Configuration for initialization to VizControl. This property could only set via settings parameter in Constructor.
			 	 */
				uiConfig : {type : "object", group : "Misc"},
				/**
				 * Names of the Dimensions to be displayed in the Chart, all available dimensions will automatically append when the property isAnalytical is false.
				 *
				 * Depending on chart type, insufficient number of visible <code>Dimension</code>s will cause error.
				 */
				visibleDimensions						: {type: "string[]", defaultValue: []},
				/**
				 * Names of the inResult dimensions.
				 *
				 * inResult dimension do not show up in chart layout, i.e. axis/legend. They do show in tooltip, popover, and in selection results.
				 */
				inResultDimensions						: {type: "string[]", defaultValue: []},
				/**
				 * Names of the Measures to be displayed in the Chart.
				 *
				 * Depending on chart type, insufficient number of visible <code>Measure</code>s will cause errors.
				 */
				visibleMeasures						  : {type: "string[]", defaultValue: []},
				/** Chart properties, refer to chart property <a href="../../vizdocs/index.html" target="_blank">documentation</a> for more details. */
				vizProperties								: {type: "object", group: "Misc"},/**
				/** Chart scales, refer to chart property <a href="../../vizdocs/index.html" target="_blank">documentation</a> for more details. */
				vizScales										: {type : "object[]", group : "Misc"},
				/** Whether or not an aggregated entity set is bound to the chart. */
				isAnalytical								 : {type: "boolean"},
				/**
				 * Chart selection behavior.
				 *
				 */
				selectionBehavior						: {type: "sap.chart.SelectionBehavior", defaultValue: sap.chart.SelectionBehavior.DataPoint},
				/**
				 * Chart selection mode.
				 *
				 */
				selectionMode			: {type: "sap.chart.SelectionMode", defaultValue: sap.chart.SelectionMode.Multi},
				/**
				 * Enable pagination mode.
				 *
				 * Pagination mode empowers users to visualize dataset page by page by scrolling back or forth. Currently there are some limitations of this mode in some chart transversal features, such as:
				 * <ol>
				 *   <li>Selection status might lost for new batch data</li>
				 *   <li>Keyboard navigation will be only available for current continuous batch data</li>
				 *	 <li>Zoom out might have inconsistent behavior, Hence the gesture in mobile might have the same issue</li>
				 *	 <li>Time charts did not enable pagination yet</li>
				 *	 <li>Series color might be inconsistent before/after jump pages</li>
				 * </ol>
				 * Please refer to release notes for details.
				 */
				enablePagination			 : {type: "boolean", defaultValue: false},
				/**
				 * 
				 Chart custom messages.
				*/
				customMessages				  : {type: "object", defaultValue: null},
				/**
				 * Chart colorings.
				 * 
				 * Holds an object with information about the possible options how colors can be applied for indicating <code>Criticality</code> or <code>Emphasis</code> in the chart. 
				 * <pre>
				 * Colorings: {
				 *     Criticality: { 
				 *         
				 *     },
				 *     Emphasis: {
				 *         
				 *     }
				 * }
				 * </pre>
				 *  
				 * Refer to<br/>
				 *   {@link sap.chart.ColoringType.Criticality}<br/>
				 *   {@link sap.chart.ColoringType.Emphasis}<br/>
				 * for detailed usage
				 */
				colorings: {type: "object", defaultValue: null},
				/**
				 * Active coloring configurations.
				 *
				 * specifies which coloring of the possible colorings is to be applied for the current chart layout. It holds an object with two properties
				 *
				 * <ol>
				 *   <li>coloring: <b>mandatory</b>, specify which kind of coloring should take effect in current chart layout. Possible values refer to {@link sap.chart.ColoringType}</li>
				 *   <li>parameters:
				 *     <ul>
				 *       <li>
				 *         <code>Criticality</code> supports two parameters: <code>"dimension"</code> and <code>"measure"</code>. Both are <b>optional</b>, one (and only one) must be provided.
				 *         This setting disambiguates when multiple colorings for different visible dimensions and measures are applicable.
				 *
				 *         <code>"measure"</code> supports two input types:
				 *           <ol>
				 *             <li><code>string</code> for single measure name</li>
				 *             <li><code>string[]</code> of multiple measure names(only supported in <b>static</b>), which is relevant in case of a <b>static</b> measure criticality defined on multiple measures.</li>
				 *           </ol>
				 *         <code>"dimension"</code> holds the dimension name as string value.
				 *       </li>
				 *       <li>
				 *         <code>Emphasis</code> supports only one parameter: <code>"dimension"</code> which is <b>optional</b>.
				 *
				 *         <code>"dimension"</code> holds the dimension name as string value.
				 *       </li>
				 *     </ul>
				 *   </li>
				 * </ol>
				 *
				 * Example:
				 * <pre>
				 * activeColoring: {
				 *     coloring: sap.chart.ColoringType.Criticality,
				 *     parameters: {
				 *         dimension: "AvailabilityStatus
				 *     }
				 * }
				 * </pre>
				 */
				activeColoring: {type: "object", defaultValue: null}

			},
			aggregations: {
				/** Actual data. It can be bound to an (analytical) OData model. */
				data	   : {type: "sap.ui.core.Element", multiple: true, bindable: "bindable"},
				/** Internal VizFrame instance which does the actual rendering work. */
				_vizFrame  : {type: "sap.viz.ui5.controls.VizFrame", multiple: false, visibility: "hidden"},
				/** Dimensions of the data. */
				dimensions : {type: "sap.chart.data.Dimension", multiple: true},
				/** Measures of the data. */
				measures   : {type: "sap.chart.data.Measure", multiple: true}
			},
			events: {
				/** fired after a drill-down operation */
				drilledDown : {
					parameters : {
						/** array of strings holding the names of the added dimensions */
						dimensions : {type : "string[]"}
					}
				},
				/** fired after a drill-up operation */
				drilledUp : {
					parameters : {
						/** array of strings holding the names of the removed dimensions */
						dimensions : {type : "string[]"}
					}
				},
				/** Event fires when the rendering ends. */
				renderComplete : {},
				/** Event fires when certain data point(s) is(are) selected, data context of selected item(s) would be passed in. */
				selectData	   : {},
				/** Event fires when certain data point(s) is(are) deselected, data context of deselected item(s) would be passed in */
				deselectData   : {}
			}
		},
		renderer: function(oRm, oControl) {
			// write the HTML into the render manager
			oRm.write("<div");
			oRm.writeControlData(oControl);
			oRm.addStyle("width", oControl.getWidth());
			oRm.addStyle("height", oControl.getHeight());
			oRm.writeStyles();
			oRm.write(">");

			oRm.renderControl(oControl.getAggregation("_vizFrame"));

			oRm.write("</div>");
		}
	});

	Chart.getMetadata().getAggregation("data")._doesNotRequireFactory = true;

	// ******** Overridden property getters/setters ********

	function vizFrameSize (sValue) {
		return sValue.indexOf("%") !== -1 ? "100%" : sValue;
	}
	Chart.prototype.setHeight = function(sValue) {
		this.setProperty("height", sValue);
		var oVizFrame = this._getVizFrame();
		if (oVizFrame) {
			oVizFrame.setHeight(vizFrameSize(this.getProperty("height")));
		}
		return this;
	};

	Chart.prototype.setWidth = function(sValue) {
		this.setProperty("width", sValue);
		var oVizFrame = this._getVizFrame();
		if (oVizFrame) {
			oVizFrame.setWidth(vizFrameSize(this.getProperty("width")));
		}
		return this;
	};

	Chart.prototype.setChartType = function(sChartType, bSuppressInvalidate) {
		this.setProperty("chartType", sChartType, bSuppressInvalidate);
		this._bIsPagingChartType =  ChartUtils.CONFIG.pagingChartTypes.indexOf(sChartType) > -1;
		if (this._isEnablePaging()) {
			this._initPagination(true);
		} else {
			var oDataset = this._getDataset();
			if (oDataset) {
				oDataset.setPagingOption(null);
			}
		}
		this._invalidateBy({
			source: this,
			keys: {
				vizFrame: true
			}
		});

		this._bNeedToApplyDefaultProperties = true;
		return this;
	};

	Chart.prototype.setColorings = function(oValue) {
		this.setProperty("colorings", oValue);

		this._invalidateBy({
			source: this,
			keys: {
				vizFrame: true,
				checkBinding: true
			}
		});

		return this;
	};

	Chart.prototype.setActiveColoring = function(oValue) {
		this.setProperty("activeColoring", oValue);

		this._invalidateBy({
			source: this,
			keys: {
				vizFrame: true,
				checkBinding: true
			}
		});

		return this;
	};

	/**
	 * Removes a dimension from the aggregation dimensions, remove a visible dimension is unsupported when the property isAnalytical is false.
	 *
	 * @public
	 *
	 * @param {int|string|sap.chart.data.Dimension} oDimension
	 * The dimension to remove or its index or id.
	 *
	 * @return {sap.chart.data.Dimension} The removed dimension or null
	 */
	Chart.prototype.removeDimension = function(oDimension) {
		var aVisibleDimensions = this._getVisibleDimensions() || [];
		var iIndex;
		if (this.getIsAnalytical() === false && oDimension && oDimension.getName()) {
			iIndex = aVisibleDimensions.indexOf(oDimension.getName());
			if (iIndex !== -1) {
				jQuery.sap.log.error('Data source does not support aggregation. The method "removeDimension" therefore cannot be used!');
				return;
			}
		}
		var oResult = this.removeAggregation("dimensions", oDimension);

		if (oResult) {
			iIndex = aVisibleDimensions.indexOf(oResult.getName());
			if (iIndex !== -1) {
				aVisibleDimensions.splice(iIndex, 1);
				this.setVisibleDimensions(aVisibleDimensions);
			}
			var aInResultDimensions = this.getInResultDimensions() || [];
			iIndex = aInResultDimensions.indexOf(oResult.getName());
			if (iIndex !== -1) {
				aInResultDimensions.splice(iIndex, 1);
				this.setInResultDimensions(aInResultDimensions);
			}
		}
		return oResult;
	};

	/**
	 * Removes all the controls from the aggregation dimensions, only works when the property isAnalytical is true.
	 *
	 * Additionally, it unregisters them from the hosting UIArea.
	 *
	 * @public
	 *
	 * @return {sap.chart.data.Dimension[]} An array of the removed elements (might be empty)
	 */
	Chart.prototype.removeAllDimensions = function() {
		var oResult;
		if (this.getIsAnalytical() === false) {
			jQuery.sap.log.error('Data source does not support aggregation. The method "removeAllDimensions" therefore cannot be used!');
		} else {
			oResult = this.removeAllAggregation("dimensions");
			this.setVisibleDimensions([]);
			this.setInResultDimensions([]);
		}
		return oResult;
	};

	/**
	 * Destroys all the dimensions in the aggregation dimensions, only works when the property isAnalytical is true.
	 * 
	 * @public
	 *
	 * @return {sap.chart.Chart} Reference to this in order to allow method chaining
	 */
	Chart.prototype.destroyDimensions = function() {
		var oResult;
		if (this.getIsAnalytical() === false) {
			jQuery.sap.log.error('Data source does not support aggregation. The method "destroyDimensions" therefore cannot be used!');
		} else {
			oResult = this.destroyAggregation("dimensions");
			this.setVisibleDimensions([]);
			this.setInResultDimensions([]);
		}
		return oResult;
	};

	Chart.prototype.removeMeasure = function(oMeasure) {
		var oResult = this.removeAggregation("measures", oMeasure);

		if (oResult) {
			var aVisibleMeasures = this._getVisibleMeasures() || [],
			iIndex = aVisibleMeasures.indexOf(oResult.getName());
			if (iIndex !== -1) {
				aVisibleMeasures.splice(iIndex, 1);
				this.setVisibleMeasures(aVisibleMeasures);
			}
		}
		return oResult;
	};

	Chart.prototype.removeAllMeasures = function() {
		var oResult = this.removeAllAggregation("measures");
		this.setVisibleMeasures([]);
		return oResult;
	};

	Chart.prototype.destroyMeasures = function() {
		var oResult = this.destroyAggregation("measures");
		this.setVisibleMeasures([]);
		return oResult;
	};
	Chart.prototype._getVisibleDimensions = function(bNormalize) {
		var oStackTop = this._getDrillStateTop();
		var aDims = oStackTop ? oStackTop.dimensions : this.getProperty("visibleDimensions");
		return bNormalize ? this._normalizeDorM(aDims, true) : aDims;
	};

	Chart.prototype.getVisibleDimensions = function() {
		var aVisibleDimensions = this._getVisibleDimensions();
		return this._aFeeds ? aVisibleDimensions.filter(function(d) {
			return this._aFeeds._unused.indexOf(d) === -1;
		}, this) : aVisibleDimensions;
	};

	Chart.prototype._getVisibleMeasures = function(bNormalize) {
		var oStackTop = this._getDrillStateTop();
		var aMsrs = oStackTop ? oStackTop.measures : this.getProperty("visibleMeasures");
		return bNormalize ? this._normalizeDorM(aMsrs) : aMsrs;
	};

	Chart.prototype.getVisibleMeasures = function() {
		var aVisibleMeasures = this._getVisibleMeasures();
		return this._aFeeds ? aVisibleMeasures.filter(function(d) {
			return this._aFeeds._unused.indexOf(d) === -1;
		}, this) : aVisibleMeasures;
	};

	/**
	 * Sets a new value for property visibleDimensions.
	 * 
	 * Names of the Dimensions to be displayed in the Chart, all available dimensions will automatically append when the property isAnalytical is false.
	 * 
	 * Depending on chart type, insufficient number of visible Dimensions will cause error.
	 * 
	 * When called with a value of null or undefined, the default value of the property will be restored.
	 * 
	 * Default value is [].
	 *
	 * @public
	 *
	 * @param {string[]} sVisibleDimensions
	 * New value for property visibleDimensions
	 *
	 * @return {sap.chart.Chart} Reference to this in order to allow method chaining
	 */
	Chart.prototype.setVisibleDimensions = function(sVisibleDimensions, bSuppressInvalidate) {
		var mSanity = this._dimensionSanityCheck({visible: sVisibleDimensions});
		this.setProperty("visibleDimensions", sVisibleDimensions, bSuppressInvalidate);
		this.setProperty("inResultDimensions", mSanity.inResult, bSuppressInvalidate);
		this._createDrillStack();
		this._invalidateBy({
			source: this,
			keys: {
				binding: true,
				dataSet: true,
				vizFrame: true
			}
		});

		return this;
	};

	Chart.prototype.setInResultDimensions = function(aInResultDimensionNames, bSuppressInvalidate) {
		var mSanity = this._dimensionSanityCheck({inResult: aInResultDimensionNames});
		this.setProperty("inResultDimensions", aInResultDimensionNames, bSuppressInvalidate);
		this.setProperty("visibleDimensions", mSanity.visible, bSuppressInvalidate);
		this._createDrillStack();
		this._invalidateBy({
			source: this,
			keys: {
				binding: true,
				dataSet: true,
				vizFrame: true
			}
		});
	};

	Chart.prototype.setVisibleMeasures = function(aMeasureNames, bSuppressInvalidate) {
		this.setProperty("visibleMeasures", aMeasureNames, bSuppressInvalidate);
		this._createDrillStack();
		this._invalidateBy({
			source: this,
			keys: {
				binding: true,
				dataSet: true,
				vizFrame: true
			}
		});
		return this;
	};

	/**
	 * Sets a new value for property enablePagination, only works for oData model.
	 *
	 * Enable pagination mode.
	 * 
	 * Pagination mode empowers users to visualize dataset page by page by scrolling back or forth. Currently there are some limitations of this mode in some chart transversal features, such as:
	 * <ol>
	 *   <li>Selection status might lost for new batch data</li>
	 *   <li>Keyboard navigation will be only available for current continuous batch data</li>
	 *	 <li>Zoom out might have inconsistent behavior, hence the gesture in mobile might have the same issue</li>
	 *	 <li>Time charts did not enable pagination yet</li>
	 *	 <li>Series color might be inconsistent before/after jump pages</li>
	 * </ol>
	 * Please refer to release notes for details.
	 *
	 * When called with a value of null or undefined, the default value of the property will be restored.
	 * NOTE: setEnablePagination currently only works in constructor
	 * 
	 * Default value is false.
	 *
	 * @public
	 *
	 * @param {boolean}	bEnablePagination
	 * New value for property enablePagination
	 *
	 * @return {sap.chart.Chart} Reference to this in order to allow method chaining
	 */
	Chart.prototype.setEnablePagination = function(bEnablePagination, bSuppressInvalidate) {
		if (!this._bIsInitialized) {
			this.setProperty("enablePagination", bEnablePagination, bSuppressInvalidate);

			this._invalidateBy({
				source: this,
				keys: {
					binding: true,
					dataSet: true,
					vizFrame: true,
					drillStack: true
				}
			});
		}
		return this;
	};

	// ******** Private helper functions ********
	/*
	 * Since we allow inResult and visible to race for a Dimension, we need to move a Dimension out of visible if it's
	 * being set as InResult, and vice versa.
	 */
	Chart.prototype._dimensionSanityCheck = function(oDims) {
		var aVisibles = oDims.visible || this.getVisibleDimensions() || [],
			aInResult = oDims.inResult || this.getInResultDimensions() || [];

		var mSummary = [].concat(aVisibles).concat(aInResult).reduce(function(mSumm, sId) {
			var bVisible  = aVisibles.indexOf(sId) !== -1,
				bInResult = aInResult.indexOf(sId) !== -1;
			if (bVisible && bInResult) {
				mSumm.common[sId] = true;
			} else if (bVisible) {
				mSumm.visible[sId] = true;
			} else if (bInResult) {
				mSumm.inResult[sId] = true;
			}

			return mSumm;
		}, {
			visible: {},
			inResult:{},
			common:  {}
		});

		mSummary.visible = Object.keys(mSummary.visible);
		mSummary.inResult = Object.keys(mSummary.inResult);
		mSummary.common = Object.keys(mSummary.common);

		return mSummary;
	};

	Chart.prototype._prepareFeeds = function() {
		if (!this._aFeeds) {
			var aDimensions = this._normalizeDorM(this._getVisibleDimensions(), true),
				aMeasures = this._normalizeDorM(this._getVisibleMeasures(), false),
				aInResults = this._normalizeDorM(this.getInResultDimensions(), true);
			this._sAdapteredChartType = this.getEnablePagination() ? this.getChartType() : ChartTypeAdapterUtils.adaptChartType(this.getChartType(), aDimensions);
			this._aFeeds = RoleFitter.fit(this._sAdapteredChartType, aDimensions, aMeasures, aInResults, this._enableSemanticPattern());
			if ((!this._aFeeds._valid || this._aFeeds._unused.length) && this._sAdapteredChartType !== this.getChartType()) {
				// fall back to original chart type if feeding is invalid for adapted chart type
				this._sAdapteredChartType = this.getChartType();
				this._aFeeds = RoleFitter.fit(this._sAdapteredChartType, aDimensions, aMeasures, aInResults);
			}
			if (this._sAdapteredChartType !== this.getChartType()) {
				this._bNeedToApplyDefaultProperties = true;
			}
		}
		return this._aFeeds;
	};



	/**
	 * Convert an array containing any number of Dimension/Measure instances (object) and Dimension/Measure names (string)
	 * an array of Dimension/Measure instances. And filter out any Dimensions/Measures that are not in the Dimension/Measure
	 * aggregation.
	 *
	 * @param {array} aMixed the mixed array of Dimension/Measure instances and names
	 * @param {boolean} bIsDimension whether the input array are Dimensions
	 * @return {array} an array of Dimension/Measure instances that present in the visible Dimension/Measure aggregation
	 *				   result.error will contain all the non-normalizable input from the mixed array passed in
	 * @private
	 */
	Chart.prototype._normalizeDorM = function(aMixed, bIsDimension) {
		var aAll = bIsDimension ? this.getDimensions() : this.getMeasures(),
			mLookUp = aAll.reduce(function(mMap, oDimOrMsr) {
				mMap[oDimOrMsr.getName()] = oDimOrMsr;
				return mMap;
			}, {}),
			clazz = bIsDimension ? Dimension : Measure;

		var oResult = aMixed.reduce(function(oResult, oNameOrDM) {
			var sName;
			if (typeof oNameOrDM === "string") {
				sName = oNameOrDM;
			} else if (oNameOrDM instanceof clazz) {
				sName = oNameOrDM.getName();
			} else {
				oResult.errors.push(oNameOrDM);
			}
			if (mLookUp[sName]) {
				oResult.normalized.push(mLookUp[sName]);
			} else {
				oResult.errors.push(oNameOrDM);
			}
			return oResult;
		}, {
			normalized: [],
			errors: []
		});

		var aNormalized = oResult.normalized;
		if (oResult.errors.length > 0) {
			aNormalized.errors = oResult.errors;
		}

		return aNormalized;
	};

	/**
	 * Calculate redundant Dimensions and Measures from selected data points (selection)
	 * against visible Dimensions and Measures.
	 *
	 * A Dimension is considered to be redundant if all selected data points share the same value for it.
	 * A Measure is considered to be redundant if none of the selected data point are of this measure.
	 *
	 * @return {object} key, value pairs for redundant Dimensions and Measures.
	 *					For Dimensions, key is the Dimension name and value is the redundant value;
	 *					For Measures, key is "measureNames" and value is an map having the redundant Measure names as keys
	 * @private
	 */
	Chart.prototype._redundantsFromSelection = function() {
		var aSelections = this._getVizFrame().vizSelection();
		if (!aSelections || aSelections.length === 0) {
			return {measureNames: {}};
		}
		var oSemanticTuples = this._getContinuesSemanticTuples();	

		var mSelectionSummary = aSelections.reduce(function(mSummary, oSelection) {
			var aInvisibleSemMsr = [];
			for (var tuple in oSemanticTuples) {
				if (oSemanticTuples.hasOwnProperty(tuple)) {
					var semanticRule = oSemanticTuples[tuple];
					if (oSelection.data[tuple]) {
						//Filter measures according with semantic relations
						aInvisibleSemMsr.push((oSelection.data[semanticRule.timeAxis] < semanticRule.projectedValueStartTime) ? semanticRule.projected : semanticRule.actual);
					} else {
						//Filter internal unbound measures which is invisible for chart.
						aInvisibleSemMsr.push(semanticRule.actual);
						aInvisibleSemMsr.push(semanticRule.projected);
					}	
				}
			}

			jQuery.each(oSelection.data, function(k, v) {
				if (!(aInvisibleSemMsr.length > 0 && aInvisibleSemMsr.indexOf(k) > -1)) {
					if (!mSummary[k]) {
						mSummary[k] = [];
					}
					if (mSummary[k].indexOf(v) === -1) {
						mSummary[k].push(v);	
					}
				}
			});
			return mSummary;
		}, {});

		var mRedundants = this._getVisibleDimensions().reduce(function(mRedundantDimensions, sDimensionName) {
			var aValues = mSelectionSummary[sDimensionName];
			if (aValues.length === 1) {
				mRedundantDimensions[sDimensionName] = aValues[0];
			}
			return mRedundantDimensions;
		}, {});

		mRedundants.measureNames = this._getVisibleMeasures().reduce(function(mRedundantMeasures, sMsrName) {
			if (!mSelectionSummary[sMsrName]) {
				mRedundantMeasures[sMsrName] = true;
			}
			return mRedundantMeasures;
		}, {});

		return mRedundants;
	};

	/**
	 * Derive a filter from the selected data points (selection).
	 * The returned Filter will make sure only the Dimension values that presents in the selection are retained.
	 *
	 * NOTE: Redundant Measures is to be handled in the request rather than here in Filter
	 *
	 * @return {sap.ui.model.Filter} the Filter instance
	 * @private
	 */
	Chart.prototype._deriveFilterFromSelection = function() {
		var aVisibleDimensions = this._getVisibleDimensions();
		var that = this;
		var aFilterCfgs = this._getVizFrame().vizSelection().map(function(oSelection) {
			var oConfig = aVisibleDimensions.reduce(function(oFilterCfg, sDimensionName) {
				var oDimension = that.getDimensionByName(sDimensionName);
				var value;
				value = oSelection.data[sDimensionName];
				if (ChartUtils.CONFIG.timeChartTypes.indexOf(that._sAdapteredChartType) > -1 &&
					 oDimension instanceof TimeDimension) {
					var oDateInstance = DateFormatUtil.getInstance(oDimension.getTimeUnit());
					if (oDateInstance) {
						var fnFormat = oDateInstance.format.bind(oDateInstance);
						value = fnFormat(new Date(oSelection.data[sDimensionName]));
					}
				}
				oFilterCfg.filters.push(new Filter({path: sDimensionName, operator: FilterOperator.EQ, value1: value}));
				oFilterCfg.signature.push(sDimensionName + "=" + oSelection.data[sDimensionName]);
				return oFilterCfg;
			}, {
				filters: [],
				signature: []
			});
			oConfig.signature = oConfig.signature.join(";");
			return oConfig;
		});

		var mUniqFilters = aFilterCfgs.reduce(function(mFilters, oCfg) {
			if (!mFilters[oCfg.signature] && oCfg.filters.length > 0) {
				mFilters[oCfg.signature] = new Filter(oCfg.filters, true);
			}
			return mFilters;
		}, {});

		var aFilters = Object.keys(mUniqFilters).map(function(k) {
			return mUniqFilters[k];
		});
		if (aFilters.length > 1) {
			return new sap.ui.model.Filter(aFilters, false);
		} else if (aFilters.length === 1) {
			return aFilters[0];
		} else {
			return null;
		}
	};

	/**
	 * Check that the dimension to be drilled down actually can be drilled down
	 *
	 * @private
	 * @param {array} aIncomingDimensions an array of Dimensions to be drilled down
	 * @return {boolean} true if the chart can drill down on all provided Dimensions, otherwise return false
	 */
	Chart.prototype._checkDrilldownValid = function(aIncomingDimensions) {
		var mVisibleDimensions = this._getVisibleDimensions().concat(this.getInResultDimensions()).reduce(function(mMap, sDimensionName) {
			mMap[sDimensionName] = true;
			return mMap;
		}, {});

		// Prevent drill down again on dimensions that are visible already
		if (aIncomingDimensions.some(function(oDim) {
			return mVisibleDimensions[oDim.getName()];
		})) {
			jQuery.sap.log.error("Drill down not possible, because one of the given dimensions is already drilled down!");
			return false;
		}

		var mArgumentDimensionNames = aIncomingDimensions.reduce(function(oResult, oDimension) {
			oResult[oDimension.getName()] = oDimension;
			return oResult;
		}, {});

		// recursively check the filter tree for a dimension which we want to drill down into
		function findFilter(oFilter) {
			if (jQuery.isArray(oFilter.aFilters)) { // Subtree
				return oFilter.aFilters.some(findFilter);
			} else { // Leaf
				return !!mArgumentDimensionNames[oFilter.sPath];
			}
		}

		var oStackTop = this._getDrillStateTop();
		if (oStackTop && oStackTop.filter && findFilter(oStackTop.filter)) {
			jQuery.sap.log.error("Drill down not possible, because one of the given dimensions is already filtered!");
			return false;
		}

		return true;
	};

	/**
	 * Create the drill stack from visible Dimensions and Measures.
	 *
	 * The created drill stack should allow user to drill up by removing one visible Dimension
	 * each time until no Dimension is left
	 * @private
	 */
	Chart.prototype._createDrillStack = function() {
		var aVisibleDimensions = this.getProperty("visibleDimensions") || [],
			aVisibleMeasures = this.getProperty("visibleMeasures") || [],
			aStack = [{
				dimensions: [],
				measures: aVisibleMeasures,
				filter: undefined
			}],
			aStackDimensions = [];

		for (var i = 0; i < aVisibleDimensions.length; i++) {
			aStackDimensions.push(aVisibleDimensions[i]);
			aStack.push({
				dimensions: aStackDimensions.slice(),
				measures: aVisibleMeasures,
				filter: undefined
			});
		}

		this._drillStateStack = aStack;
	};

	/**
	 * Invalidate certain aspect of the Chart control so it gets updated accordingly on the re-render phase.
	 *
	 * It is not required to update all aspects on each invalidation because some causes only changes certain, but not all, aspect.
	 * For example
	 *	 a. If the cause is Dimension/Measure property (label, role, or format etc) change, it is not necessary to update the binding and drill state;
	 *	 b. If the cause is visibleDimensions/visibleMeasures change, it is required to update almost everything.
	 * and the cases goes on.
	 *
	 * @param {object} oCause the cause of the invalidation
	 * @private
	 */
	Chart.prototype._invalidateBy = function(oCause) {
		var oSource = oCause.source;

		var aAdditionalDims = this._oCandidateColoringSetting ? (this._oCandidateColoringSetting.additionalDimensions || []) : [];
		if (oSource === this) {
			jQuery.each(oCause.keys || {}, function(k, v) {
				this._markForUpdate(k, v);
			}.bind(this));
		} else if (oSource instanceof Measure && this._getVisibleMeasures().indexOf(oSource.getName()) !== -1) {
			this._markForUpdate("dataSet", true);
			this._markForUpdate("vizFrame", true);
			if (oCause.property === "unitBinding") {
				this._markForUpdate("binding", true);
			}
		} else if (oSource instanceof Dimension && this._getVisibleDimensions().concat(aAdditionalDims).indexOf(oSource.getName()) !== -1) {
			this._markForUpdate("dataSet", true);
			this._markForUpdate("vizFrame", true);
			if (oSource.getDisplayText() && (oCause.property === "textProperty" || oCause.property === "displayText" )) {
				this._markForUpdate("binding", true);
			}
		}

		this.invalidate(oCause);
	};

	Chart.prototype._handleNonAnalyticalFeeding = function() {
		var that = this;
		var inResult = this.getInResultDimensions();
		var visibleDimensions = this._getVisibleDimensions(),
			allDimensions = this.getDimensions().map(function(oValue) {
				return oValue.getName();
			});
		//arr contains textProperty
		var arr = [];
		allDimensions.forEach(function(dimension) {
			if (that.getDimensionByName(dimension)) {
				var textProperty = that.getDimensionByName(dimension).getTextProperty();
				if (textProperty) {
					arr.push(textProperty);
				}
			}
		});

		/*Merge visibleDimensions and allDimensions, remove duplicate items, and textProperty and inresultDimension.
		 *Keep the user settings of visinleDimensions, then auto append other dimensions for user.
		 *Filter unitBinding/textProperty/inResult behind auto appending to prevent this three dimensions are already exist in visibleDimensons.
		 */
		var vDimensions = visibleDimensions.concat(allDimensions.filter(function(item) {
			return (visibleDimensions.indexOf(item) < 0);
		})).filter(function(item) {
			return (arr.indexOf(item) < 0) && (inResult.indexOf(item) < 0);
		});
		this.setProperty("visibleDimensions", vDimensions);
		this._createDrillStack();
	};

	// ******** Private updaters. These updaters are meant to be triggered by the _render function. ********

	Chart.prototype._markForUpdate = function(key, bNeedUpdate) {
		if (!this._mNeedToUpdate) {
			this._mNeedToUpdate = {};
		}
		this._mNeedToUpdate[key] = bNeedUpdate;
		var fnOnInvalidate = this._updaters.onInvalidate[key];
		if (fnOnInvalidate) {
			fnOnInvalidate.call(this);
		}
	};
	Chart.prototype._updaters = (function() {
		return {
			onInvalidate: {
				vizFrame: function() {
					this._aFeeds = null;
					this._bColoringParsed = null;
				},
				checkBinding: function() {
					this._bColoringParsed = null;
				},
				binding: function() {
					this._bColoringParsed = null;
				}
			},
			checkBinding: function() {
				// sync point for colorings & activeColoring properties to decide if binding should be updated
				var oCandidateColoringSetting = this._getCandidateColoringSetting();
				var aAdditionalDimensions = oCandidateColoringSetting.additionalDimensions;
				var aAdditionalMeasures = oCandidateColoringSetting.additionalMeasures;
				if ((aAdditionalDimensions && aAdditionalDimensions.length) || 
					(aAdditionalMeasures && aAdditionalMeasures.length)) {
					this._markForUpdate("binding", true);
				}
			},
			drillStack: function() {
				this._createDrillStack();
			},
			dataSet: function() {
				var oDataset = this._getDataset();
				oDataset.updateData.apply(oDataset, arguments);
			},
			/* This BINDING is NOT the chart binding */
			binding: function() {
				var oBinding = this._getDataset().getBinding("data"),
					inResult = this.getInResultDimensions();
				if (!oBinding) {
					return;
				}


				var aDimensions = this._getVisibleDimensions(true).concat(this._normalizeDorM(inResult, true));
				var aMeasures = this._getVisibleMeasures(true);
				DataSourceUtils.updateModel(this.getIsAnalytical())(this, aDimensions, aMeasures);

				var oStackTop = this._getDrillStateTop();
				if (aDimensions.length > 0 || aMeasures.length > 0) {
					this._getVizFrame()._pendingDataRequest(true); // prevent vizFrame from updating by an empty dataset before data is received
					this.setBusy(true);
				}
				oBinding.filter((oStackTop && oStackTop.filter) ? oStackTop.filter : undefined);

				this._resetPagingOptions();
			},
			vizFrame: function() {
				var that = this,
					oDataset = this._getDataset(),
					oVizFrame = this._getVizFrame(),
					mMeasureRange = this._mMeasureRange || {};

				oDataset.removeAllAggregation("dimensions", true);
				oDataset.removeAllAggregation("measures", true);

				oVizFrame.removeAllAggregation("feeds", true);

				if (this.getIsAnalytical() === false) {
					this._handleNonAnalyticalFeeding();
				}

				var aFeeds = this._prepareFeeds();
				aFeeds._def.dim.forEach(function(oDim) {
					oDataset.addAggregation("dimensions", oDim, true);
				}, this);
				aFeeds._def.msr.forEach(function(oMsr) {
					if (oMsr) {
						var oRange = mMeasureRange[oMsr.getIdentity()];
						if (oRange) {
							oMsr.setRange([oRange.min, oRange.max]);
						}
						if (!that.getDimensionByName(oMsr.getUnit())) {
							oMsr.setUnit(null);
						}
						oDataset.addAggregation("measures", oMsr, true);
					}
				}, this);
				aFeeds.forEach(function(oFeedItem) {
					oVizFrame.addFeed(oFeedItem);
				});
				this._semanticTuples = aFeeds._semanticTuples;

				var aDatasetContexts = aFeeds._context || [];
				var oCandidateColoringSetting = this._getCandidateColoringSetting();
				var aAdditionalMeasures = oCandidateColoringSetting.additionalMeasures || [];
				var aAdditionalDimensions = oCandidateColoringSetting.additionalDimensions || [];

				aAdditionalMeasures.forEach(function(sMsr) {
					aDatasetContexts.push({
						id: sMsr,
						showInTooltip: false
					});
					oDataset.addMeasure(new MeasureDefinition({
						name: sMsr,
						identity: sMsr,
						value: '{' + sMsr + '}'
					}));
				});

				aAdditionalDimensions.forEach(function(sDim) {
					aDatasetContexts.push({
						id: sDim,
						showInTooltip: false
					});
					oDataset.addDimension(new DimensionDefinition({
						name: sDim,
						identity: sDim,
						value: '{' + sDim + '}'
					}));
				});

				if (!this._mNeedToUpdate['binding']) {
					// loop cached data if there is no binding change
					this._markForUpdate('loopData', true);
				}
				oDataset.setContext(aDatasetContexts);

				oVizFrame.invalidate();
				oDataset.invalidate();
				oVizFrame.setVizType(this._sAdapteredChartType);
				
				oVizFrame.setVizProperties(this._getEffectiveProperties());
				oVizFrame._setCustomMessages(this.getCustomMessages());
			},
			loopData: function() {
				var oVizFrame = this._getVizFrame();
				try {
					this._prepareData();
				} catch (e) {
					if (e instanceof ChartLog) {
						e.display();
					} else {
						throw e;
					}
				}
				var oVizProperties = this._getEffectiveProperties();
				//TODO: merge 'using DisplayName' logic into one loop in 'prepareData'
				this._usingDisplayNameForSemantics(oVizProperties);
				oVizFrame.setVizProperties(oVizProperties);
				this._setEffectiveScales();
			}
		};

		//return [oDrillStackUpdater, oDataSetUpdater, oVizFrameUpdater, oBindingUpdater];
	})();

	// ******** Private Accessors ********
	Chart.prototype._getDrillStateTop = function() {
		return this._drillStateStack ? this._drillStateStack[this._drillStateStack.length - 1] : null;
	};

	Chart.prototype._getVizFrame = function() {
		return this.getAggregation("_vizFrame");
	};

	Chart.prototype._getDataset = function() {
		var oVizFrame = this._getVizFrame();
		return oVizFrame ? oVizFrame.getDataset() : null;
	};

	Chart.prototype._restoreUserSemanticColoringProperties = function() {
		// restore user's dataPointStyle in properties since Coloring use the same entry
		this._oColoringsDataPointStyle = {
			plotArea: {
				dataPointStyle: this._oDataPointStyle
			},
			legend: {
				title: this._oLegendtitle
			}
		};
		this._oColoringScale = null;
	};

	Chart.prototype._prepareData = function() {
		// 1) get context handler of Colorings
		var oCandidateColoringSetting = {}, oColoringHandler;
		var bSemanticPattern = this.getVisibleMeasures().some(function(sMsr) {
			return this.getMeasureByName(sMsr).getSemantics() !== sap.chart.data.MeasureSemantics.Actual;
		}.bind(this));
		// do not consider combination usage with Semantic Pattern in initial implementation
		if (!bSemanticPattern && 
		  ((this._sAdapteredChartType === "heatmap" && this._oVizColorScale === undefined) ||
		  (this._sAdapteredChartType !== "heatmap" && !this._oDataPointStyle))) {
			oCandidateColoringSetting = this._getCandidateColoringSetting();
			oColoringHandler = oCandidateColoringSetting.contextHandler;
		}

		// 2) loop context if necessary in Colorings
		var aContextHandlers = [];
		if (oColoringHandler) {
			aContextHandlers.push(oColoringHandler);
			this._loopContext(aContextHandlers);
		}

		// 3) Generate semantic rules with parsed Colorings
		if (!bSemanticPattern) {
			if (oCandidateColoringSetting.ruleGenerator) {
				var rule;
				try {
					rule = oCandidateColoringSetting.ruleGenerator();
					this._oColoringsDataPointStyle = rule.properties;
					this._oColoringScale = rule.colorScale;
				} catch (e) {
					if (e instanceof ChartLog) {
						e.display();
					} else {
						throw e;
					}
					this._restoreUserSemanticColoringProperties();
				}
			} else {
				this._restoreUserSemanticColoringProperties();
			}
		}
	};

	Chart.prototype._getContexts = function() {
		var oBinding = this.getBinding("data");
		if (oBinding) {
			var iStart, iLength;
			if (this._isEnablePaging() && this._bNeedPaging) {
				iStart = this._oPagingOption.iStartIndex;
				if (this._oPagingOption.iPageNo === 0) {
					iLength = this._oPagingOption.iLength * 2;
				} else {
					iLength = this._oPagingOption.iLength;
				}
			} else {
				iStart = 0;
				iLength = oBinding instanceof sap.ui.model.analytics.AnalyticalBinding ? oBinding.getTotalSize() : oBinding.getLength();
			}
			return oBinding.getContexts(iStart, iLength);
		} else {
			return [];
		}
	};

	Chart.prototype._loopContext = function(aContextHandlers) {
		var aContexts = this._getContexts();
		if (aContexts.length > 0 && !aContexts.dataRequested) {
			var that = this;
			aContexts.forEach(function(oContext) {
				aContextHandlers.forEach(function(fnContextHandler) {
					fnContextHandler.call(that, oContext);
				});	
			});
		}
	};

	Chart.prototype._bindingChangeListener = function() {
		var oVizFrame = this._getVizFrame();

		//Here we can get the source dataset, and then set the data's displayValue to lengend's displayName in the semantic rules of vizProperties automatically for specific requirement.
		oVizFrame.invalidate(); // prevent an unnecessary immediate VizFrame re-render, re-render should happen after all invalidates
		this.setBusy(false);
		if (this._isEnablePaging()) {
			if (this._bNeedTotal) {
				this._initPagination();
				this._bNeedTotal = false;
			} else if (this._bNeedPaging) {
				var thumbPosition = oVizFrame._states().plot.transform.translate.position;
				this._updatePage(thumbPosition);
			}
		} else {
			this._mMeasureRange = {};
			oVizFrame._pendingDataRequest(false);
			oVizFrame.invalidate();
		}
		
		try {
			this._prepareData();
		} catch (e) {
			if (e instanceof ChartLog) {
				e.display();
			}
		}

		var oVizProperties = this._getEffectiveProperties();
		//TODO: merge 'using DisplayName' logic into one loop in 'prepareData'
		this._usingDisplayNameForSemantics(oVizProperties);

		oVizFrame.setVizProperties(oVizProperties);
		this._setEffectiveScales();
	};

	Chart.prototype._initPagination = function(bNoQueryMinMax) {
		var oBinding = this.getBinding("data");
		if (!oBinding) {
			return;
		}
		var iTotalSize = oBinding instanceof sap.ui.model.analytics.AnalyticalBinding ? oBinding.getTotalSize() : oBinding.getLength();
		if (iTotalSize >= 0) {
			this._iTotalSize = iTotalSize;
			if (this._iTotalSize > this._iPageSize * 2) {
				this._iMaxPageNo = Math.floor(this._iTotalSize / this._iPageSize) - 1;
				this._iRemainingRecords = this._iTotalSize % this._iPageSize;
				this._bNeedPaging = true;
				this._iOffset = null;
				var dataRatio = this._iPageSize / this._iTotalSize;
				this._oPagingOption = {
					bEnabled: true,
					iStartIndex: 0,
					iLength: this._iPageSize,
					sMode: "reset",
					thumbRatio: dataRatio,
					iPageNo: 0
				};
				if (bNoQueryMinMax) {
					this._getVizFrame()._pendingDataRequest(false);
				} else {
					//invalidate vizframe until we got minMax
					this._getVizFrame()._pendingDataRequest(true);
					this._queryMinMax(this._measureRangeReceivedHandler.bind(this));
				}
			} else {
				this._mMeasureRange = {};
				this._bNeedPaging = false;
				this._oPagingOption = {
					bEnabled: false,
					iStartIndex: 0,
					iLength: this._iTotalSize
				};
				this._getVizFrame()._pendingDataRequest(false);
			}
			this._getDataset().setPagingOption(this._oPagingOption);
		}
	};

	Chart.prototype._resetPagingOptions = function() {
		var that = this;
		var oBinding = this.getBinding("data");
		var oDataset = this._getDataset();
		if (!oDataset || !oBinding) {
			return;
		}
		if (this._isEnablePaging()) {
			var aFeeds = this._prepareFeeds();
			aFeeds._order = aFeeds._order.filter(function(sFeed) {
				return sFeed !== "MND" && that.getDimensions().map(function(oValue){return oValue.getName();}).indexOf(sFeed) > -1;
			});
			if (aFeeds._order.length) {
				var aSorters = this._aFeeds._order.map(function(sProperty) {
					return new Sorter(sProperty);
				});
				oBinding.sort(aSorters);
			}

			this._bNeedTotal = true;
			this._oPagingOption = {
				bEnabled: false,
				iStartIndex: 0,
				iLength: this._iPageSize * 2,
				iPageNo: 0
			};
			oDataset.setPagingOption(this._oPagingOption);

			this._oColorTracker.clear();
			this._getVizFrame()._runtimeScales(this._oColorTracker.get(), true);
		} else {
			oDataset.setPagingOption(null);
		}
		this._oColoringStatus = {};
		this._mMeasureRange = {};
	};
	/************* Semantic Pattern's internal method *******************/
	Chart.prototype._enableSemanticPattern = function(){
		//If dataPointStyle or seriesStyle are set by user, semantic pattern shouldn't work. 
		return !(this._oDataPointStyle || this._oSeriesStyle);
	};

	Chart.prototype._hasSemanticPattern = function(){
		return this._semanticTuples && this._semanticTuples.length > 0;
	};

	Chart.prototype._getContinuesSemanticTuples = function(){
		var tuples = {};
		if (this._hasSemanticPattern()) {
			tuples = this._semanticTuples.reduce(function(arrs, tuple){
				if (tuple.semanticMsrName) {
					arrs[tuple.semanticMsrName] = tuple; 
				}
				return arrs;
			}, {});
		}
		return tuples;
	};

	Chart.prototype._getContinuesSemanticMap = function(){
		var tuples = [];
		if (this._hasSemanticPattern()) {
			tuples = this._semanticTuples.filter(function(tuple){
				return tuple.projectedValueStartTime;
			});
		}
		return tuples;
	};

	Chart.prototype._getInternalVisibleMeasures = function(){
		var aMsrs = this._getVisibleMeasures();
		if (this._hasSemanticPattern()) {
			aMsrs = aMsrs.concat(this._getContinuesSemanticMap().map(function(tuple){
				return tuple.semanticMsrName;
			}));
		}
		return aMsrs;
	};

	Chart.prototype._buildSelectedDataPoints = function(oBinding, aDataPoints){
		//For get/setSelectedDataPoints API
		//Build vizframe's selected datapoint structure. 
		var aMsrs = this._getInternalVisibleMeasures(),
			aDims = this._getVisibleDimensions().concat(this.getInResultDimensions()),
			aSelectedDataPoints = this._getEffectiveContinuesDataPoints(aDataPoints);
		return SelectionAPIUtils.buildSelectionVizCtx(aMsrs, aDims, oBinding, aSelectedDataPoints);
	};

	Chart.prototype._getEffectiveContinuesSeries = function(aSeries){
		var aSelectedSeries = aSeries.slice(), continuesSemanticTuples = this._getContinuesSemanticMap();
		if (this._hasSemanticPattern()) {
			var msrsMap = aSelectedSeries.map(function(series){
				return series.measures;
			});

			continuesSemanticTuples.forEach(function(tuple){
				if (msrsMap.indexOf(tuple.actual) > -1 || msrsMap.indexOf(tuple.projected) > -1) {
					aSelectedSeries = aSelectedSeries.filter(function(series){
						return series.measures !== tuple.actual && series.measures !== tuple.projected;
					});
					if (msrsMap.indexOf(tuple.actual) > -1 && msrsMap.indexOf(tuple.projected) > -1) {
						aSelectedSeries.push({
							measures : tuple.semanticMsrName
						});
					}
				}
			});
		}
		return aSelectedSeries;
	};

	Chart.prototype._getEffectiveContinuesDataPoints = function(aDataPoints){
		var aSelectedDataPoints = aDataPoints.slice(),  continuesSemanticTuples = this._getContinuesSemanticMap();
		if (this._hasSemanticPattern()) {
			var actIndex, proIndex, measures, tuple;
			for (var i = 0; i < aSelectedDataPoints.length; i++) {
				measures = aSelectedDataPoints[i].measures;
				for (var j = 0; j < continuesSemanticTuples.length; j++) {
					tuple = continuesSemanticTuples[j];
					actIndex = measures.indexOf(tuple.actual);
					if (actIndex > -1) {
						measures.splice(actIndex, 1);
					}
					proIndex = measures.indexOf(tuple.projected);
					if (proIndex > -1) {
						measures.splice(proIndex, 1);
					}
					if (actIndex > -1 || proIndex > -1) {
						measures.push(tuple.semanticMsrName);
					}
				}
			}	
		}
		return aSelectedDataPoints;
	};

	Chart.prototype._buildSelectEventData = function(data) {
		if (data && data.length > 0 && this._hasSemanticPattern()) {
			var value, tuple;
			var continuesSemanticTuples = this._getContinuesSemanticMap();
			for (var i = 0; i < data.length; i++) {
				value = jQuery.extend(true, {}, data[i].data);
				for (var j = 0; j < continuesSemanticTuples.length; j++) {
					tuple = continuesSemanticTuples[j];
					if (value.measureNames === tuple.semanticMsrName) {
						//Need to filter interval unbound measures
						//TODO check null value case 
						if (value[tuple.timeAxis] < tuple.projectedValueStartTime) {
							value.measureNames = tuple.actual;
							delete value[tuple.projected];
							delete value[tuple.semanticMsrName];
						} else {
							value.measureNames = tuple.projected;
							delete value[tuple.actual];
							delete value[tuple.semanticMsrName];
						}
					} else {
						if (value[tuple.actual] && value.measureNames !== tuple.actual) {
							delete value[tuple.actual];	
						}
						if (value[tuple.projected] && value.measureNames !== tuple.projected) {
							delete value[tuple.projected];
						}
					}
				}
				data[i].data = value;
			}
		}
	};
	// ******** overridden functions ********

	// override standard aggregation methods for 'data' and report an error when they are used
	/**
	 * Unsupported.
	 * Chart manages the "data" aggregation only via data binding. The method "addData" therefore cannot be used programmatically!
	 *
	 * @public
	 */
	Chart.prototype.addData = function() {
		jQuery.sap.log.error('Chart manages the "data" aggregation only via data binding. The method "addData" therefore cannot be used programmatically!');
	};

	/**
	 * Unsupported.
	 * Chart manages the "data" aggregation only via data binding. The method "destroyData" therefore cannot be used programmatically!
	 *
	 * @public
	 */
	Chart.prototype.destroyData = function() {
		jQuery.sap.log.error('Chart manages the "data" aggregation only via data binding. The method "destroyData" therefore cannot be used programmatically!');
	};

	/**
	 * Unsupported.
	 * Chart manages the "data" aggregation only via data binding. The method "getData" therefore cannot be used programmatically!
	 *
	 * @public
	 */
	Chart.prototype.getData = function() {
		jQuery.sap.log.error('Chart manages the "data" aggregation only via data binding. The method "getData" therefore cannot be used programmatically!');
	};

	/**
	 * Unsupported.
	 * Chart manages the "data" aggregation only via data binding. The method "indexOfData" therefore cannot be used programmatically!
	 *
	 * @public
	 */
	Chart.prototype.indexOfData = function() {
		jQuery.sap.log.error('Chart manages the "data" aggregation only via data binding. The method "indexOfData" therefore cannot be used programmatically!');
	};

	/**
	 * Unsupported.
	 * Chart manages the "data" aggregation only via data binding. The method "insertData" therefore cannot be used programmatically!
	 *
	 * @public
	 */
	Chart.prototype.insertData = function() {
		jQuery.sap.log.error('Chart manages the "data" aggregation only via data binding. The method "insertData" therefore cannot be used programmatically!');
	};

	/**
	 * Unsupported.
	 * Chart manages the "data" aggregation only via data binding. The method "removeData" therefore cannot be used programmatically!
	 *
	 * @public
	 */
	Chart.prototype.removeData = function() {
		jQuery.sap.log.error('Chart manages the "data" aggregation only via data binding. The method "removeData" therefore cannot be used programmatically!');
	};

	/**
	 * Unsupported.
	 * Chart manages the "data" aggregation only via data binding. The method "removeAllData" therefore cannot be used programmatically!
	 *
	 * @public
	 */
	Chart.prototype.removeAllData = function() {
		jQuery.sap.log.error('Chart manages the "data" aggregation only via data binding. The method "removeAllData" therefore cannot be used programmatically!');
	};

    Chart.prototype._createOData4SAPAnalyticsModel = function(oModel) {
		var oOData4SAPAnalyticsModel = null;
		try {
			oOData4SAPAnalyticsModel = new odata4analytics.Model(new odata4analytics.Model.ReferenceByModel(oModel));
		} catch (exception) {
			return undefined;
		}
		return oOData4SAPAnalyticsModel;

	};

	/**
	 * Gets current value of property isAnalytical.
	 * 
	 * Whether or not an aggregated entity set is bound to the chart.
	 *
	 * The proeprty isAnalytical will programmatically set according to data source. When the data source has an aggregated entity set, isAnalytical is true, otherwise it's false.
	 *
	 * @public
	 *
	 * @return {boolean} Value of property isAnalytical
	 */
	Chart.prototype.getIsAnalytical = function() {
		return this.getProperty("isAnalytical");
	};

	/**
	 * Whether or not an aggregated entity set is bound to the chart. Deprecated.
	 * 
	 * @public
	 */
	Chart.prototype.setIsAnalytical = function(oValue, bSuppressInvalidate) {
		if (this._bIsInitialized) {
			jQuery.sap.log.error('The proeprty isAnalytical will programmatically set according to data source. The method "setIsAnalytical" therefore cannot be used!');
		} else {
			this.setProperty("isAnalytical", oValue, bSuppressInvalidate);
		}
	};

	Chart.prototype._setIsAnalyticalProperty = function(oOData4SAPAnalyticsModel, oBindingInfo) {
		var oValue = oOData4SAPAnalyticsModel.findQueryResultByName(DataSourceUtils.getEntitySet(this.getIsAnalytical())(oBindingInfo)) !== undefined;
		if (this.getIsAnalytical() !== oValue) {
			this.setProperty("isAnalytical", oValue);
		}
	};

	Chart.prototype.bindAggregation = function(sName, oBindingInfo) {
		if (sName === "data") {
			// This may fail, in case the model is not yet set.
			// If this case happens, the ODataModelAdapter is added by the overriden _bindAggregation,
			// which is called during setModel(...)
			var oModel = this.getModel(oBindingInfo.model);
			var oOData4SAPAnalyticsModel;
			if (oModel) {
				if (oModel instanceof sap.ui.model.json.JSONModel) {
					if (this.getIsAnalytical() !== false) {
						this.setProperty("isAnalytical", false);
					} else if (this.getEnablePagination() !== false) {
						this.setProperty("enablePagination", false);
					}
				} else {
					oOData4SAPAnalyticsModel = this._createOData4SAPAnalyticsModel(oModel);
					this._setIsAnalyticalProperty(oOData4SAPAnalyticsModel, oBindingInfo);
				}
				if (this.getIsAnalytical()) {
					if (oBindingInfo) {
						oBindingInfo.parameters = jQuery.extend(true, {}, {
									analyticalInfo: [{name: ""}] ,
									useBatchRequests: true,
									provideGrandTotals: false,
									provideTotalsResultSize: false,
									autoexpand: false,
									reloadSingleUnitMeasures: true,
									noPaging: true
								},
								oBindingInfo.parameters);

						if (this._isEnablePaging()) {
							var oPagingBindingInfo = {
										noPaging: false
							};
							oBindingInfo.parameters = jQuery.extend(true, oBindingInfo.parameters, oPagingBindingInfo);
						}
					}

					ODataModelAdapter.apply(oModel);
					if (oOData4SAPAnalyticsModel) {
						oModel.setAnalyticalExtensions(oOData4SAPAnalyticsModel);
					}
				}
			}
		}
		return BaseControl.prototype.bindAggregation.apply(this, arguments);
	};

	Chart.prototype._bindAggregation = function(sName, oBindingInfo) {
		if (sName === "data") {
			// This may fail, in case the model is not yet set.
			// If this case happens, the ODataModelAdapter is added by the overriden _bindAggregation, which is called during setModel(...)
			var oModel = this.getModel(oBindingInfo.model);
			if (oModel) {
				if (oModel instanceof sap.ui.model.json.JSONModel) {
					if (this.getIsAnalytical() !== false) {
						this.setProperty("isAnalytical", false);
					} else if (this.getEnablePagination() !== false) {
						this.setProperty("enablePagination", false);
					}
				} else {
					var oOData4SAPAnalyticsModel = this._createOData4SAPAnalyticsModel(oModel);
					this._setIsAnalyticalProperty(oOData4SAPAnalyticsModel, oBindingInfo);
				}
				if (this.getIsAnalytical()) {
					if (oBindingInfo) {
						oBindingInfo.parameters = jQuery.extend(true, {}, {
									analyticalInfo: [{name: ""}] ,
									useBatchRequests: true,
									provideGrandTotals: false,
									provideTotalsResultSize: false,
									autoexpand: false,
									reloadSingleUnitMeasures: true,
									noPaging: true
								},
								oBindingInfo.parameters);

						if (this._isEnablePaging()) {
							var oPagingBindingInfo = {
								noPaging: false
							};
							oBindingInfo.parameters = jQuery.extend(true, oBindingInfo.parameters, oPagingBindingInfo);
						}

					}

					ODataModelAdapter.apply(oModel);
					if (oOData4SAPAnalyticsModel) {
						oModel.setAnalyticalExtensions(oOData4SAPAnalyticsModel);
					}
				}

				this._deriveColumns(oModel, oBindingInfo);
			}
			var oDataset = this._getDataset(),
				oOldDataBinding = oDataset.getBinding("data");

			if (oOldDataBinding) {
				oOldDataBinding.detachChange(this._bindingChangeListener, this);
			}
			oDataset.bindAggregation("data", oBindingInfo);

			var oNewDataBinding = oDataset.getBinding("data");
			if (oNewDataBinding) {
				oDataset.getBinding("data").attachChange(this._bindingChangeListener, this);
			}

			this._invalidateBy({
				source: this,
				keys: {
					binding: true,
					vizFrame: true
				}
			});
		} else {
			BaseControl.prototype._bindAggregation.apply(this, arguments);
		}
	};

	Chart.prototype.unbindAggregation = function(sName, bSuppressReset) {
		if (sName === "data") {
			var oDataset = this._getDataset();
			if (oDataset) {
				oDataset.unbindAggregation.apply(oDataset, arguments);
			}
			bSuppressReset = true; // since we explicitly prohibit call to destroyData
		}
		return BaseControl.prototype.unbindAggregation.apply(this, [sName, bSuppressReset]);
	};

	Chart.prototype.unbindData = function() {
		//remove all dimensions/visibleDimensions,measures/visibleMeasures
		if (!this.getIsAnalytical()) {
			this.removeAllAggregation("dimensions");
			this.removeAllAggregation("measures");
			this.setProperty("visibleDimensions", []);
			this.setProperty("inResultDimensions", []);
			this.setProperty("visibleMeasures", []);
			this._createDrillStack();
		}
		this.unbindAggregation("data");
	};

	Chart.prototype._deriveColumns = function(oModel, oBindingInfo) {
		// derive dimensions and measures from metadata, if not yet set
		var aDimensions = this.getAggregation("dimensions");
		var aMeasures = this.getAggregation("measures");
		if ((aDimensions === null || aDimensions.length === 0) && (aMeasures === null || aMeasures.length === 0)) {
			var mColumns = DataSourceUtils.deriveColumns(this.getIsAnalytical())(oModel, oBindingInfo);
			mColumns.dimensions.forEach(this.addDimension.bind(this));
			mColumns.measures.forEach(this.addMeasure.bind(this));
		}
	};

	/*
	 * @override
	 * @private
	 */
	Chart.prototype.onBeforeRendering = function() {
		BaseControl.prototype.onBeforeRendering.apply(this, arguments);
		var aOrder = ["onInvalidate", "drillStack", "dataSet", "vizFrame", "checkBinding", "binding", "loopData"];
		// ensure "vizFrame" updaters earlier than binding since semantic coloring depends on auto-feeding
		aOrder.forEach(function(key) {
			if (this._mNeedToUpdate[key]) {
				this._updaters[key].call(this);
			}
		}.bind(this));

		jQuery.each(this._mNeedToUpdate, function(key) {
			this._mNeedToUpdate[key] = false;
		}.bind(this));
	};

	// Override to prevent Basecontrol._render from createing DOM node, since Chart performs rendering via _vizFrame
	Chart.prototype.onAfterRendering = function () {
		this._showLoading(this._bLoading);
	};

	Chart.prototype.onlocalizationChanged = function() {
		this._invalidateBy({
			source: this,
			keys: {
				vizFrame: true
			}
		});
	};

	/*
	 * @override
	 */
	Chart.prototype.exit = function() {
		this._getDataset().unbindAggregation('data', true);
		BaseControl.prototype.exit.apply(this, arguments);
		var oVizFrame = this._getVizFrame();
		if (this._delegateEventHandlers) {
			this._delegateEventHandlers.forEach(function(oHandler) {
				oVizFrame["detach" + oHandler.name](oHandler.handler, this);
				delete oHandler.handler;
			}, this);
			delete this._delegateEventHandlers;
		}
		oVizFrame.detachRenderComplete(this._vizFrameRenderCompleteHandler, this);
	};

	
	/*
	 * @override
	 */
	Chart.prototype.applySettings = function() {
		this._oDataPointStyle = null;
		this._oSeriesStyle = null;
		
		sap.ui.core.Control.prototype.applySettings.apply(this, arguments);

		var oDataset = new FlattenedDataset();

		// make applicationSet : fiori as default. If we write it in the metadata, the jsdoc could not be generated correctly.
		var uiConfig = jQuery.extend(true, {}, {
			'applicationSet': 'fiori'
		}, this.getUiConfig());
		this.setUiConfig(uiConfig);
		this._bNeedToApplyDefaultProperties = true;

		var oVizFrame = new VizFrame({
			width: vizFrameSize(this.getWidth()),
			height: vizFrameSize(this.getHeight()),
			vizType: this.getChartType(),
			uiConfig: this.getUiConfig(),
			vizProperties: jQuery.extend(true, {
				'title' : {
					'visible' : false
				}
			}, this._getEffectiveProperties())
		});

		oVizFrame.setDataset(oDataset);
		oVizFrame.attachRenderComplete(null, this._updateLoadingIndicator.bind(this));

		this._rendered = false;

		oVizFrame.attachEventOnce("renderComplete", function() {
			this._rendered = true;
		}, this);

		// The loading page should hide after renderfail when in pagination.
		oVizFrame.attachEvent("renderFail", null, function(e) {
			this._showLoading(false);
		}, this);

		oVizFrame._pendingDataRequest(true);
		this.setAggregation("_vizFrame", oVizFrame);
		this._delegateEvents();

		this._bNeedTotal = true;
		this._bNeedPaging = false;
		this._iPageSize = 500;
		this._oColorTracker = new SeriesColorTracker();
		this._sAdapteredChartType = this.getChartType();
		this._bIsInitialized = true;
		this._oCandidateColoringSetting = {};

		this._oDataPointStyle = null;
		this._oLegendtitle = null;
		this._oColoringStatus = {};
	};

	/**
	 * Set the chart custom messages. Supported messages please refer to enum {@link sap.chart.MessageId}.
	 *
	 * The user should handle the message localization.
	 *
	 * Example:
	 *
	 * <pre>
	 * oChart.setCustomMessages({
	 *	 'NO_DATA': "No data. Please change your filter"
	 * });
	 * </pre>
	 *
	 *When called with an invalid value, the default value will be restored.
	 *
	 * @param {object} oCustomMessages object containing customMessage values to update
	 * @public
	 * @returns {sap.chart.Chart} 
	 */
	Chart.prototype.setCustomMessages = function(oCustomMessages) {
		this.setProperty("customMessages", oCustomMessages);
		var oVizFrame = this._getVizFrame();
		if (oVizFrame) {
			oVizFrame._setCustomMessages(oCustomMessages);
		}
		return this;
	};


	// ******** Public API ********

	/**
	 * Reset to visible layout.
	 * @public
	 * @returns {sap.chart.Chart} Reference to <code>this</code> in order to allow method chaining
	 */
	Chart.prototype.resetLayout = function() {
		this._invalidateBy({
			source: this,
			keys: {
				binding: true,
				vizFrame: true,
				drillStack: true,
				dataSet: true
			}
		});
		return this;
	};

	// ******************** Datapoint Selection ********************
	/**
	 * Select one or more data points, specified by datapoint objects.
	 *
	 * Datapoint object has the following structure:
	 * <pre>
	 * {
	 * 		groupId:  "groupId",		  // group ID (optional)
	 * 		index:		index,				  // index of the data in the group
	 * 		measures: ["measureId"]   // measure IDs
	 * }
	 * </pre>
	 *
	 * Only works when selectionBehavior is "DATAPOINT"
	 *
	 * @param {array} aDataPoints an array of datapoint objects.
	 *
	 * @public
	 * @returns {sap.chart.Chart} Reference to <code>this</code> in order to allow method chaining
	 */
	Chart.prototype.setSelectedDataPoints = function(aDataPoints) {
		if (this.getSelectionMode() !== SelectionMode.None) {
			var oBinding = this.getBinding("data"),
			oVizFrame = this._getVizFrame();
			if (!oBinding || !oVizFrame || this.getSelectionBehavior().toUpperCase() !== "DATAPOINT") {
				return this;
			}
			oVizFrame.vizSelection([], {clearSelection: true});
			oVizFrame.vizSelection(this._buildSelectedDataPoints(oBinding, aDataPoints), {
				selectionMode: this.getSelectionMode()
			});
		}
		return this;

	};

	/**
	 * Add one or more data points to current data point selection, specified by datapoint objects.
	 *
	 * Datapoint object has the following structure:
	 * <pre>
	 * {
	 * 		groupId:  "groupId",		  // group ID (optional)
	 * 		index:		index,				  // index of the data in the group
	 * 		measures: ["measureId"]   // measure IDs
	 * }
	 * </pre>
	 *
	 * Only works when selectionBehavior is "DATAPOINT"
	 *
	 * @param {array} aDataPoints an array of datapoint objects.
	 *
	 * @public
	 *
	 * @returns {sap.chart.Chart} Reference to <code>this</code> in order to allow method chaining
	 */
	Chart.prototype.addSelectedDataPoints = function(aDataPoints) {
		if (this.getSelectionMode() !== SelectionMode.None) {
			var oBinding = this.getBinding("data"),
			oVizFrame = this._getVizFrame();
			if (!oBinding || !oVizFrame || this.getSelectionBehavior().toUpperCase() !== "DATAPOINT") {
				return this;
			}
			oVizFrame.vizSelection(this._buildSelectedDataPoints(oBinding, aDataPoints), {
				selectionMode: SelectionMode.Multi
			});
		}
		return this;
	};

	/**
	 * Return a total number and an array of datapoint objects (including a Context object) of currently selected data points.
	 *
	 * Datapoint object has the following structure:
	 * <pre>
	 * {
	 * 		index:		index,		  // index of the data in the group
	 * 		measures: ["measureId"]   // measure IDs (data points created from the same Context object
	 * 														  // differing only in measure names are merged together)
	 * 		context:  [Context]		   // Context object
	 *		unit: {
	 *			measureId : ""	  // unit of measure
	 *		}
	 *		dataName: {
	 *			measureId or dimensionId : ""      // dataName of measure or dimension
	 *		}
	 * }
	 * </pre>
	 *
	 * Only works when selectionBehavior is "DATAPOINT"
	 *
	 * @public
	 *
	 * @return {object} a total number of selected data points, and an array of datapoint objects.
	 */
	Chart.prototype.getSelectedDataPoints = function() {
		var oVizFrame = this._getVizFrame();
		if (!oVizFrame || this.getSelectionBehavior().toUpperCase() !== "DATAPOINT") {
			return {
				count: 0,
				dataPoints: []
			};
		}
		var oSemanticTuples = this._getContinuesSemanticTuples();
		var mVisibleMsrs = this._getVisibleMeasures(),
			oDataSet = this._getDataset(),
			aSelectedDataPoints = oVizFrame.vizSelection(), mSelectedDataPoints = {};
		for (var i = 0, len = aSelectedDataPoints.length; i < len; i++) {
			var dataPoint = aSelectedDataPoints[i],
				idx = dataPoint.data._context_row_number;
			if (!mSelectedDataPoints[idx]) {
				mSelectedDataPoints[idx] = {
					index: idx,
					measures: [],
					context: oDataSet.findContext({"_context_row_number": idx})
				};
			}
			dataPoint.measures = SelectionAPIUtils.filterVisibleMsr(dataPoint.data, mVisibleMsrs);
			if (!jQuery.isEmptyObject(oSemanticTuples)) {
				SelectionAPIUtils.filterSemMsr(oSemanticTuples, mVisibleMsrs, dataPoint);
			}
			mSelectedDataPoints[idx].measures = mSelectedDataPoints[idx].measures.concat(dataPoint.measures);
			if (dataPoint.unit) {
				mSelectedDataPoints[idx].unit = jQuery.extend(true, mSelectedDataPoints[idx].unit, dataPoint.unit);
			}
			if (dataPoint.dataName) {
				mSelectedDataPoints[idx].dataName = jQuery.extend(true, mSelectedDataPoints[idx].dataName, dataPoint.dataName);
			}
		}
		return {
			count: aSelectedDataPoints.length,
			dataPoints: Object.keys(mSelectedDataPoints).map(function(id) {
				return mSelectedDataPoints[id];
			})
		};
	};

	/**
	 * Deselect one or more data points from current data point selections, specified by datapoint objects.
	 *
	 * Datapoint object has the following structure:
	 * <pre>
	 * {
	 * 		groupId:  "groupId",		  // group ID (optional)
	 * 		index:		index,				  // index of the data in the group
	 * 		measures: ["measureId"]   // measure IDs
	 * }
	 * </pre>
	 *
	 * Only works when selectionBehavior is "DATAPOINT"
	 *
	 * @public
	 *
	 * @param {array} aDataPoints an array of datapoint objects.
	 *
	 * @returns {sap.chart.Chart} Reference to <code>this</code> in order to allow method chaining
	 */
	Chart.prototype.removeSelectedDataPoints = function(aDataPoints) {
		if (this.getSelectionMode() !== SelectionMode.None) {
			var oBinding = this.getBinding("data"),
			oVizFrame = this._getVizFrame();
			if (!oVizFrame || this.getSelectionBehavior().toUpperCase() !== "DATAPOINT") {
				return this;
			}
			var aToRemove = this._buildSelectedDataPoints(oBinding, aDataPoints);
			oVizFrame.vizSelection(aToRemove, {
				deselection: true
			});
		}
		return this;
	};

	// ******************** Category Selection ********************
	/**
	 * Select one or more categories, specified by category objects.
	 *
	 * Category object has the following structure:
	 * <pre>
	 * {
	 *	   measure: measureName,
	 *	   dimensions: {
	 *		   dimensionName1: dimensionValue1,
	 *		   dimensionName2: dimensionValue2,
	 *		   ...
	 *	   }
	 * }
	 * </pre>
	 *
	 * Only works when selectionBehavior is "CATEGORY"
	 *
	 * @public
	 *
	 * @param {array} aCategories an array of category objects
	 *
	 * @returns {sap.chart.Chart} Reference to <code>this</code> in order to allow method chaining
	 */
	Chart.prototype.setSelectedCategories = function(aCategories) {
		if (this.getSelectionMode() !== SelectionMode.None) {
			var oVizFrame = this._getVizFrame(),
			sBehavior = this.getSelectionBehavior().toUpperCase();
			if (!oVizFrame || sBehavior !== "CATEGORY") {
				return this;
			}
			oVizFrame.vizSelection([], {clearSelection: true});
			oVizFrame.vizSelection(aCategories.map(SelectionAPIUtils.toVizCSCtx), {
				selectionMode: this.getSelectionMode()
			});
		}
		return this;
	};

	/**
	 * Add one or more categories to current category selections, specified by category objects.
	 *
	 * Category object has the following structure:
	 * <pre>
	 * {
	 *	   measure: measureName,
	 *	   dimensions: {
	 *		   dimensionName1: dimensionValue1,
	 *		   dimensionName2: dimensionValue2,
	 *		   ...
	 *	   }
	 * }
	 * </pre>
	 *
	 * Only works when selectionBehavior is "CATEGORY"
	 *
	 * @public
	 *
	 * @param {array} aCategories an array of category objects
	 *
	 * @returns {sap.chart.Chart} Reference to <code>this</code> in order to allow method chaining
	 */
	Chart.prototype.addSelectedCategories = function(aCategories) {
		if (this.getSelectionMode() !== SelectionMode.None) {
			var oVizFrame = this._getVizFrame(),
			sBehavior = this.getSelectionBehavior().toUpperCase();
			if (!oVizFrame || sBehavior !== "CATEGORY") {
				return this;
			}
			oVizFrame.vizSelection(aCategories.map(SelectionAPIUtils.toVizCSCtx), {
				selectionMode: SelectionMode.Multi
			});
		}
		return this;
	};

	/**
	 * Deselect one or more categories from current category selections, specified by category objects.
	 *
	 * Category object has the following structure:
	 * <pre>
	 * {
	 *	   measure: measureName,
	 *	   dimensions: {
	 *		   dimensionName1: dimensionValue1,
	 *		   dimensionName2: dimensionValue2,
	 *		   ...
	 *	   }
	 * }
	 * </pre>
	 *
	 * Only works when selectionBehavior is "CATEGORY"
	 *
	 * @public
	 *
	 * @param {array} aCategories an array of category objects
	 *
	 * @returns {sap.chart.Chart} Reference to <code>this</code> in order to allow method chaining
	 */
	Chart.prototype.removeSelectedCategories = function(aCategories) {
		if (this.getSelectionMode() !== SelectionMode.None) {
			var oVizFrame = this._getVizFrame(),
			sBehavior = this.getSelectionBehavior().toUpperCase();
			if (!oVizFrame || sBehavior !== "CATEGORY") {
				return this;
			}
			oVizFrame.vizSelection(aCategories.map(SelectionAPIUtils.toVizCSCtx), {
				deselection: true
			});
		}
		return this;
	};

	/**
	 * Return category objects of currently selected categories and a total number of selected data points.
	 *
	 * Category object has the following structure:
	 * <pre>
	 * {
	 *	   measure: measureName,
	 *	   dimensions: {
	 *		   dimensionName1: dimensionValue1,
	 *		   dimensionName2: dimensionValue2,
	 *		   ...
	 *	   }
	 * }
	 * </pre>
	 *
	 * Return 0 and empty list if selectionBehavior is not "CATEGORY"
	 *
	 * @public
	 *
	 * @return {object} a total number of selected data points, and an array of category objects for selected categories.
	 */
	Chart.prototype.getSelectedCategories = function() {
		var oVizFrame = this._getVizFrame(),
			sBehavior = this.getSelectionBehavior().toUpperCase();
		if (!oVizFrame || sBehavior !== "CATEGORY") {
			return {
				count: 0,
				categories: []
			};
		} else {
			var aSelections = oVizFrame.vizSelection();
			return {
				count: aSelections.length,
				categories: (aSelections.category || []).map(SelectionAPIUtils.fromVizCSCtx)
			};
		}
	};

	// ******************** Series Selection ********************
	/**
	 * Select one or more series, specified by series objects.
	 *
	 * Series object has the following structure:
	 * <pre>
	 * {
	 *	   measure: measureName,
	 *	   dimensions: {
	 *		   dimensionName1: dimensionValue1,
	 *		   dimensionName2: dimensionValue2,
	 *		   ...
	 *	   }
	 * }
	 * </pre>
	 *
	 * Only works when selectionBehavior is "SERIES"
	 *
	 * @public
	 *
	 * @param {array} aSeries an array of series objects
	 *
	 * @returns {sap.chart.Chart} Reference to <code>this</code> in order to allow method chaining
	 */
	Chart.prototype.setSelectedSeries = function(aSeries) {
		if (this.getSelectionMode() !== SelectionMode.None) {
			var oVizFrame = this._getVizFrame(),
			sBehavior = this.getSelectionBehavior().toUpperCase();
			if (!oVizFrame || sBehavior !== "SERIES") {
				return this;
			}
			oVizFrame.vizSelection([], {clearSelection: true});
			var aSelectedSeries = this._getEffectiveContinuesSeries(aSeries);
			oVizFrame.vizSelection(aSelectedSeries.map(SelectionAPIUtils.toVizCSCtx), {
				selectionMode: this.getSelectionMode()
			});
		}
		return this;
	};

	/**
	 * Add one or more series to current series selections, specified by series objects.
	 *
	 * Series object has the following structure:
	 * <pre>
	 * {
	 *	   measure: measureName,
	 *	   dimensions: {
	 *		   dimensionName1: dimensionValue1,
	 *		   dimensionName2: dimensionValue2,
	 *		   ...
	 *	   }
	 * }
	 * </pre>
	 *
	 * Only works when selectionBehavior is "SERIES"
	 *
	 * @public
	 *
	 * @param {array} aSeries an array of series objects
	 *
	 * @returns {sap.chart.Chart} Reference to <code>this</code> in order to allow method chaining
	 */
	Chart.prototype.addSelectedSeries = function(aSeries) {
		if (this.getSelectionMode() !== SelectionMode.None) {
			var oVizFrame = this._getVizFrame(),
			sBehavior = this.getSelectionBehavior().toUpperCase();
			if (!oVizFrame || sBehavior !== "SERIES") {
				return this;
			}
			var aSelectedSeries = this._getEffectiveContinuesSeries(aSeries);
			oVizFrame.vizSelection(aSelectedSeries.map(SelectionAPIUtils.toVizCSCtx), {
				selectionMode: SelectionMode.Multi
			});
		}
		return this;
	};

	/**
	 * Deselect one or more series from current series selections, specified by series objects.
	 *
	 * Series object has the following structure:
	 * <pre>
	 * {
	 *	   measure: measureName,
	 *	   dimensions: {
	 *		   dimensionName1: dimensionValue1,
	 *		   dimensionName2: dimensionValue2,
	 *		   ...
	 *	   }
	 * }
	 * </pre>
	 *
	 * Only works when selectionBehavior is "SERIES"
	 *
	 * @public
	 *
	 * @param {array} aSeries an array of series objects
	 *
	 * @returns {sap.chart.Chart} Reference to <code>this</code> in order to allow method chaining
	 */
	Chart.prototype.removeSelectedSeries = function(aSeries) {
		if (this.getSelectionMode() !== SelectionMode.None) {
			var oVizFrame = this._getVizFrame(),
			sBehavior = this.getSelectionBehavior().toUpperCase();
			if (!oVizFrame || sBehavior !== "SERIES") {
				return this;
			}
			var aSelectedSeries = this._getEffectiveContinuesSeries(aSeries);
			oVizFrame.vizSelection(aSelectedSeries.map(SelectionAPIUtils.toVizCSCtx), {
				deselection: true
			});
		}
		return this;
	};

	/**
	 * Return series objects of currently selected series and a total number of selected data points.
	 *
	 * Series object has the following structure:
	 * <pre>
	 * {
	 *	   measure: measureName,
	 *	   dimensions: {
	 *		   dimensionName1: dimensionValue1,
	 *		   dimensionName2: dimensionValue2,
	 *		   ...
	 *	   }
	 * }
	 * </pre>
	 *
	 * Return 0 and empty list if selectionBehavior is not "SERIES"
	 *
	 * @public
	 *
	 * @return {object} object containing a total number of selected data points,
	 * and an array of series objects for selected series.
	 *
	 */
	Chart.prototype.getSelectedSeries = function() {
		var oVizFrame = this._getVizFrame(),
			sBehavior = this.getSelectionBehavior().toUpperCase();
		if (!oVizFrame || sBehavior !== "SERIES") {
			return {
				count: 0,
				series: []
			};
		} else {
			var aSelections = oVizFrame.vizSelection(),
				aSeries = (aSelections.series || []).map(SelectionAPIUtils.fromVizCSCtx),
				aSemanticMsrs = [], semanticTuples = this._getContinuesSemanticTuples();

			aSeries = aSeries.filter(function(series){
				var accepted = true;
				if (series && series.measures) {
					var semanticTuple = semanticTuples[series.measures];
					if (semanticTuple &&  semanticTuple.semanticMsrName === series.measures) {
						aSemanticMsrs.push({
							measures : semanticTuple.actual
						});
						aSemanticMsrs.push({
							measures : semanticTuple.projected
						});
						accepted = false;
					}
				}
				return accepted;
			});
			aSeries = aSeries.concat(aSemanticMsrs);
			return {
				count: aSelections.length,
				series: aSeries
			};
		}
	};

	// ******** Drill down/up API ********

	/**
	 * Drill down on specific Dimension(s), only works when the property isAnalytical is true.
	 * 
	 * The drill down Dimension(s) must present in the Dimension aggregation
	 * and must NOT present in previous drill down or be visible already.
	 *
	 * @public
	 *
	 * @param {array} vDimensions an array, or just a single instance, of either Dimension instance or Dimension name to drill down
	 */
	Chart.prototype.drillDown = function(vDimensions) {
		if (this.getIsAnalytical() === false) {
			jQuery.sap.log.error('Data source does not support drillDown/drillUp. The method "drillDown" therefore cannot be used!');
			return;
		}
		// make sure that only dimensions are drilled down
		if (vDimensions && !(vDimensions instanceof Array)) {
			vDimensions = [vDimensions];
		}
		var aDimensions = this._normalizeDorM(vDimensions, true);

		if (aDimensions.length === 0) {
			return;
		}
		if (!this._checkDrilldownValid(aDimensions)) {
			jQuery.sap.log.warning("Drill down not possible for " + aDimensions + ". Already drilled down.");
			return;
		}

		var oStackTop = this._getDrillStateTop(),
			mRedundants = this._redundantsFromSelection(),
			oSelectionFilter = this._deriveFilterFromSelection();

		var oNewFilter;
		if (oSelectionFilter) {
			oNewFilter = !(oStackTop && oStackTop.filter) ? oSelectionFilter : new Filter([oSelectionFilter, oStackTop.filter], true);
		}

		// dimension(s) can be used for drill down
		this._drillStateStack.push({
			dimensions: oStackTop.dimensions.slice().concat(aDimensions.map(function(oDim) {
				return oDim.getName();
			})).filter(function(sDim) {
				return !mRedundants[sDim];
			}),
			measures:  oStackTop.measures.filter(function(sMsr) {
				return !mRedundants.measureNames[sMsr];
			}),
			filter: oNewFilter,
			redundant: mRedundants
		});

		var aDimensionNames = aDimensions.map(function(oDim) {
			return oDim.getName();
		});
		this.fireDrilledDown({
			dimensions: aDimensionNames
		});
		this._invalidateBy({
			source: this,
			keys: {
				binding: true,
				vizFrame: true
			}
		});
	};

	/**
	 * Drill up to previous drill down state, only works when the property isAnalytical is true.
	 *
	 * @param {Integer} iIndex index of drill state in history to drill up. Default to the previous state in history if available.
	 *
	 * @public
	 */
	Chart.prototype.drillUp = function(iIndex) {
		if (this.getIsAnalytical() === false) {
			jQuery.sap.log.error('Data source does not support drillDown/drillUp. The method "drillUp" therefore cannot be used!');
			return;
		}
        if (arguments.length === 0) {
			iIndex = this._drillStateStack.length - 2;
		}
		var oNewStackTop = this._drillStateStack[iIndex];
		if (oNewStackTop && iIndex != this._drillStateStack.length - 1) {
			var oPreviousState = this._drillStateStack.pop();
			this._drillStateStack.splice(iIndex + 1);
			this.fireDrilledUp({
				dimensions: oPreviousState.dimensions.filter(function(d) {
					return oNewStackTop.dimensions.indexOf(d) === -1;
				})
			});
			this._invalidateBy({
				source: this,
				keys: {
					binding: true,
					vizFrame: true
				}
			});
		}
	};

	/**
	 * Return all drill down states, only works when the property isAnalytical is true.
	 * 
	 * @return {Object[]} array of drill state objects
	 * @public
	 */
	Chart.prototype.getDrillStack = function() {
		if (this.getIsAnalytical() === false) {
			jQuery.sap.log.error('Data source does not support drillDown/drillUp. The method "getDrillStack" therefore cannot be used!');
			return;
		} 
		return jQuery.map(this._drillStateStack || [], function(oState, i) {
			return {
				dimension: oState.dimensions.slice(),
				measure: oState.measures.slice(),
				filter: oState.filter
			};
		});
	};

	/**
		 * Setter for property uiConfig. uiConfig could only set via settings parameter
		 * of constructor.
		 *
		 * uiConfig from base type could config the instance. Supported uiConfig
		 * keyword: applicationSet, showErrorMessage
		 *
		 * Example:
		 *
		 * <pre>
		 * var chart = new sap.chart.Chart({
		 *  'chartType' : 'bar',
		 *  'uiConfig' : {
		 *		  'applicationSet' : 'fiori',
		 *		  'showErrorMessage' : true
		 *  }
		 * });
		 * </pre>
		 *
		 * @param {object}
		 *						oUiConfig the UI configuration
		 * @public
		 * @name sap.chart.Chart#setUiConfig
		 * @function
		 */
	Chart.prototype.setUiConfig = function(oUiConfig) {
		this.setProperty("uiConfig", oUiConfig);
		if (this._getVizFrame()) {
			this._getVizFrame().setUiConfig(oUiConfig);
		}
	};

	var VizPropertiesHelper = (function() {
		var BLACKLIST = [
			"interaction.selectability.mode",		// via setSelectionMode API
			"interaction.selectability.behavior"	// via setSelectionBehavior API
		];

		function deleteProp(obj, propPath) {
			var target = obj,
				vals;
			vals = propPath.reduce(function(entries, prop) {
				if (target.hasOwnProperty(prop)) {
					entries.push({parent: target, val: target[prop], key:prop});
					target = target[prop];
				}
				return entries;
			}, []);
			if (vals.length !== propPath.length) {
				return;
			}
			var entry = vals.pop();
			delete entry.parent[entry.key];
			while (vals.length > 0) {
				entry = vals.pop();
				if (Object.keys(entry.val).length > 0) {
					return;
				} else {
					delete entry.parent[entry.key];
				}
			}
		}

		function sanitize(oVizProperties, type) {
			var oResult = jQuery.extend(true, {}, oVizProperties);
			BLACKLIST.forEach(function(prop) {
				delete oResult[prop];
				deleteProp(oResult, prop.split("."));
			});
			return oResult;
		}
		return {
			sanitize: sanitize,
			modify: function(oProps, sKey, fnReplace) {
				var aPath = sKey.split("."),
					oNode = oProps;
				while (aPath.length > 1 && oNode.hasOwnProperty(aPath[0])) {
					oNode = oNode[aPath.shift()];
				}
				var sProp = aPath[0];
				if (aPath.length === 1 && oNode.hasOwnProperty(sProp)) {
					oNode[sProp] = fnReplace(oNode[sProp]);
				}
			}
		};
	})();

	/**
	 * Change Chart's properties.
	 *
	 * Chart's properties will be updated with the parameter.
	 *
	 * Refer to chart property <a href="../../vizdocs/index.html" target="_blank">documentation</a> for more details.
	 *
	 * @param {object}
	 *			  oVizProperties object containing vizProperty values to update
	 * @public
	 */
	Chart.prototype.setVizProperties = function(oVizProperties) {
		oVizProperties = VizPropertiesHelper.sanitize(oVizProperties);
		this.setProperty("vizProperties", oVizProperties);
		this._oLegendtitle = oVizProperties.legend ? oVizProperties.legend.title : null;
		
		if (oVizProperties.plotArea) {
			if (oVizProperties.plotArea.dataPointStyle) {
				this._oDataPointStyle = oVizProperties.plotArea.dataPointStyle;
				this._invalidateBy({
					source: this,
					keys: {
						loopData: true
					}
				});
			}
			if (oVizProperties.plotArea.seriesStyle) {
				this._oSeriesStyle = oVizProperties.plotArea.seriesStyle;
			}
		}

		if (this._getVizFrame()) {
			this._getVizFrame().setVizProperties(this._getEffectiveProperties());
		}
	};

	/**
	 * Return Chart's properties.
	 *
	 * Refer to chart property <a href="../../vizdocs/index.html" target="_blank">documentation</a> for more details.
	 *
	 * @returns {object} the Chart properties object
	 * @public
	 */
	Chart.prototype.getVizProperties = function() {
		var oVizFrame = this._getVizFrame();
		var oVizProps = VizPropertiesHelper.sanitize(oVizFrame ? oVizFrame.getVizProperties() : this.getProperty("vizProperties"));

		function stripUnit(oFmtStr) {
			var oFormatter = sap.viz.api.env.Format.numericFormatter();
			if (!oFormatter || jQuery.type(oFormatter.stripUnit) !== "function") {
				return oFmtStr;
			}

			if (jQuery.type(oFmtStr) === "string") {
				return oFormatter.stripUnit(oFmtStr);
			} else if (jQuery.type(oFmtStr) === "object") {
				jQuery.each(oFmtStr, function(k, v){
					oFmtStr[k] = oFormatter.stripUnit(v);
				});
				return oFmtStr;
			} else {
				return oFmtStr;
			}
		}

		VizPropertiesHelper.modify(oVizProps, "plotArea.dataLabel.formatString", stripUnit);
		VizPropertiesHelper.modify(oVizProps, "tooltip.formatString", stripUnit);

		return oVizProps;
	};

	/**
	 * Change Chart's scales.
	 *
	 * Chart's scales will be updated with the parameters.
	 *
	 * Refer to chart property <a href="../../vizdocs/index.html" target="_blank">documentation</a> for more details.
	 *
	 * @param {object[]}
	 *			  oVizScales array of vizScale objects
	 * @public
	 */
	Chart.prototype.setVizScales = function(oVizScales) {
		this.setProperty("vizScales", oVizScales);
		this._oVizColorScale = oVizScales.filter(function(oVizScale) {
			return oVizScale.feed === "color";
		})[0];
		if (this._getVizFrame()) {
			this._getVizFrame().setVizScales(oVizScales);
		}
	};

	/**
	 * Return Chart's scales.
	 *
	 * Refer to chart property <a href="../../vizdocs/index.html" target="_blank">documentation</a> for more details.
	 *
	 * @returns {object[]} an array of scale objects
	 * @public
	 */
	Chart.prototype.getVizScales = function() {
		var oVizFrame = this._getVizFrame();
		return oVizFrame ? oVizFrame.getVizScales() : this.getProperty("vizScales");

	};

	// ******** Delegations of VizFrame API ********
	/**
	 * Get the UID for Chart. It supports other controls to connect to a viz instance.
	 *
	 * @return {string} Chart UID
	 * @public
	 */
	Chart.prototype.getVizUid = function() {
		return this._getVizFrame().getVizUid();
	};

	/**
	 * Zoom the chart plot.
	 *
	 * Example:
	 * <pre>
	 *	var oChart = new sap.chart.Chart(...);
	 *	oChart.zoom({direction: "in"});
	 * </pre>
	 *
	 * @param {object} oConfig
	 *			  contains a "direction" attribute with value "in" or "out" indicating zoom to enlarge or shrink respectively
	 * @public
	 */
	Chart.prototype.zoom = function(oConfig) {
		this._getVizFrame().zoom(oConfig);
	};

	// ******** Delegations of VizFrame events ********
	var DELEGATED_EVENTS = ["selectData", "deselectData"];
	Chart.prototype._delegateEvents = function() {
		if (this._delegateEventHandlers) {
			return;
		}
		var oVizFrame = this._getVizFrame();
		this._delegateEventHandlers = DELEGATED_EVENTS.map(function(sEvent) {
			var sName = sEvent.charAt(0).toUpperCase() + sEvent.slice(1);
			var handler = function(oEvent) {
				var oParameters = oEvent.getParameters();
				this._buildSelectEventData(oParameters.data);
				delete oParameters.id;
				this.fireEvent(sEvent, oParameters);
			};
			handler = handler.bind(this);

			oVizFrame["attach" + sName](null, handler);
			return {
				name: sName,
				handler: handler
			};
		}, this);

		this._vizFrameRenderCompleteHandler = vizFrameRenderCompleteHandler.bind(this);
		oVizFrame.attachRenderComplete(null, this._vizFrameRenderCompleteHandler);
		oVizFrame.attachEvent("_scroll", scrollHandler.bind(this));
	};

	/**
	 * @private
	 */
	Chart.getChartTypes = sap.chart.api.getChartTypes;

	/**
	 * Returns available and unavailable chart types with current Dimensions and Measures.
	 * An error info will be returned along with each unavailable chart types.
	 *
	 * <pre>
	 * {
	 *		 available: [{
	 *				 chart: "chartType"
	 *		 }, ...],
	 *		 unavailable: [{
	 *				 chart: "chartType"
	 *				 error: {
	 *						 missing: {
	 *								 Dimension: n,
	 *								 Measure: n,
	 *								 DateTimeDimension: n
	 *						 }
	 *				 }
	 *		 }, ...]
	 * }
	 * </pre>
	 *
	 * @public
	 *
	 * @returns {object} chart types and errors for unavailable chart types, grouped by availability
	 */
	Chart.prototype.getAvailableChartTypes = function () {
		var aDims = this._getVisibleDimensions(true),
			aMsrs = this._getVisibleMeasures(true);
		return ChartUtils.CONFIG.chartTypes.reduce(function(oResult, sChartType) {
			var oCompatibility = RoleFitter.compatible(sChartType, aDims, aMsrs);
			if (oCompatibility.compatible) {
				oResult.available.push({chart: sChartType});
			} else {
				var oMissing = {};
				if (oCompatibility.error.missing.dim) {
					oMissing.Dimension = oCompatibility.error.missing.dim;
				}
				if (oCompatibility.error.missing.time) {
					oMissing.DateTimeDimension = oCompatibility.error.missing.time;
				}
				if (oCompatibility.error.missing.msr) {
					oMissing.Measure = oCompatibility.error.missing.msr;
				}
				oResult.unavailable.push({
					chart: sChartType,
					error: oMissing
				});
			}
			return oResult;
		}, {
			available: [],
			unavailable: []
		});
	};

	/*
	Chart.prototype._openContextMenu = function(oEvent) {
		var oMenu = this.getContextMenu();
		var bKeyboard = oEvent.type == "keyup";
		var eDock = sap.ui.core.Popup.Dock;
		var oSource = oEvent.getSource();
		oMenu.open(bKeyboard, oSource, eDock.BeginTop, eDock.BeginBottom, oSource);
	};

	Chart.prototype._initContextMenu = function()  {
		if (! this._mContextMenuItem){
			this._mContextMenuItem = {};
		}
		if (! this._mDimensionMenuItem){
			this._mDimensionMenuItem = {};
		}
		if (! this._mChartTypeMenuItem){
			this._mChartTypeMenuItem = {};
		}
		var oContextMenu = new Menu(this.getId() + "-ContextMenu");
		var aItems = this._getContextMenuItems(oContextMenu.sId);
		for (var i = 0; i < aItems.length; i++) {
			var aSubItems = this._getContextMenuItems(aItems[i].sId);
			if (aSubItems && aSubItems.length > 0 ) {
				var oSubmenu = new Menu();
				for (var j = 0; j < aSubItems.length; j++) {
					oSubmenu.addItem(aSubItems[j]);
				}
				aItems[i].setSubmenu(oSubmenu);
			};
			oContextMenu.addItem(aItems[i]);
		}
		this.setContextMenu(oContextMenu);
	};

	Chart.prototype.getContextMenu = function() {
		// initialize context menu on first get request (may come from hosting app )
		if (!this.getAggregation("contextMenu")) {
			this._initContextMenu();
		}
		return this.getAggregation("contextMenu");
	};

	Chart.prototype.ngetContextMenuItems = function() {
		this.getContextMenu(); // make sure it is initialized

		return this._mContextMenuItem;
	};

	Chart.prototype._getContextMenuItems = function(sId) {
		var aItems = [];
		var that = this;
		var sSubId = sId.slice(sId.indexOf("-")+1);
		var sSubIdLast = sId.slice(sId.lastIndexOf("-")+1);

		if (sSubIdLast == "ContextMenu") {

			// add drill down sub menu
			this._mDimensionMenuItem["@@drillDownMenuItem@@"] = this._createContextMenuItem(
				sSubId + "-DrillDownBy", "Drill Down By", null, null,	null, null
			);
			aItems.push(this._mDimensionMenuItem["@@drillDownMenuItem@@"]);
			this._mContextMenuItem["DRILL_DOWN"] = this._mDimensionMenuItem["@@drillDownMenuItem@@"];

			// add drill up item
			this._mDimensionMenuItem["@@drillUpMenuItem@@"] = this._createContextMenuItem(
				sSubId + "-DrillUp", "Drill Up",	null, null, null, function() {
					that.drillUp();
				}
			);
			aItems.push(this._mDimensionMenuItem["@@drillUpMenuItem@@"]);
			this._mContextMenuItem["DRILL_UP"] = this._mDimensionMenuItem["@@drillUpMenuItem@@"];

			// add chart types sub menu
			var oSubMenu = this._createContextMenuItem(
				sSubId + "-ChartType", "Set Chart Type", null, null, null, null
			);

			oSubMenu.getSubmenu = function() {
				// update menu items for available chart types
				var aAvailableChartTypeName = that.getAvailableChartTypes();
				for (var sChartTypeMenuItemName in that._mChartTypeMenuItem) {
					var bIsAvailable = aAvailableChartTypeName.indexOf(sChartTypeMenuItemName) != -1;
					that._mChartTypeMenuItem[sChartTypeMenuItemName].setVisible(bIsAvailable);
				}
				that._mChartTypeMenuItem[that.getProperty("chartType")].setVisible(false);

				// this._mChartTypeMenuItem
				return sap.ui.unified.MenuItemBase.prototype.getSubmenu.apply(this);
			}
			aItems.push(oSubMenu);
			this._mContextMenuItem["SET_CHART_TYPE"] = oSubMenu;
		} else if (sSubIdLast == "ChartType") {

			var aChartTypes = this.getChartTypes();
			for (var i = 0; i < aChartTypes.length; i++) {
				this._mChartTypeMenuItem[aChartTypes[i]] = this._createContextMenuItem(
					sSubId + "-" + aChartTypes[i],
					that.getChartTypeLabel(aChartTypes[i]),
					null,
					"chartType",
					aChartTypes[i],
					function(oEvent) {
						that.setChartType(oEvent.getParameter("item").data("chartType"));
						//							that._updateFeeds();
					}
				);
				aItems.push(this._mChartTypeMenuItem[aChartTypes[i]]);
			}

		} else if (sSubIdLast == "DrillDownBy" ) {
			var aAggregationDimensions = this.getDimensions();
			var aVisibleDimensions = this.getVisibleDimensions();
			var mVisibleDimensionNames = aVisibleDimensions.reduce(function(oResult, oDimension) {
				oResult[oDimension.getName()] = oDimension;
				return oResult;
			}, {});

			// create drill down menu items
			for (var i = 0; i < aAggregationDimensions.length; i++) {
				var oDimension = aAggregationDimensions[i];
				this._mDimensionMenuItem[oDimension.getName()] = this._createContextMenuItem(
					sSubId + "-" + oDimension.getName(),
					oDimension.getLabel(),
					null,
					"dimensionName",
					oDimension.getName(),
					function(oEvent) {
						oEvent.oSource.setVisible(false);
						that.drillDown(oEvent.getParameter("item").data("dimensionName"));
					}
				); // TODO change to ID
				if (mVisibleDimensionNames[oDimension.getName()]) {
					this._mDimensionMenuItem[oDimension.getName()].setVisible(false);
				}
				aItems.push(this._mDimensionMenuItem[oDimension.getName()]);
			}
		}

		return aItems;
	};

	Chart.prototype._createContextMenuItem = function(sId, sTextI18nKey, sIcon, sDataKey, sDataValue, fHandler) {
		return new MenuItem(this.getId() + "-" + sId, {
			text: sTextI18nKey, //this.oResBundle.getText(sTextI18nKey),
			icon: sIcon ? "sap-icon://" + sIcon : null,
			customData: [{key: sDataKey, value: sDataValue}],
			select: fHandler || function() {}
		});
	};
	*/



	Chart.prototype._getEffectiveProperties = function() {
		var oVizProperties = {};
		if (this._bNeedToApplyDefaultProperties) {
			oVizProperties = jQuery.extend(true, oVizProperties, this._getDefaultVizProperties());
			this._bNeedToApplyDefaultProperties = false;
		}
		oVizProperties = jQuery.extend(true, oVizProperties,
			MeasureSemanticsUtils.getSemanticVizProperties(this._sAdapteredChartType, this._semanticTuples),
			this._oColoringsDataPointStyle,
			this.getProperty("vizProperties"), 
			this._getHostedVizProperties(), 
			this._getPagingVizProperties(),
			this._getTimeProperties());

		return oVizProperties;
	};

	Chart.prototype._setEffectiveScales = function() {
		var oVizFrame = this._getVizFrame();
		if (this._oColoringScale) {
			oVizFrame.setVizScales([this._oColoringScale]);
		}
		// TODO: reset color scale in future since this feature is not ready currently
	};

	Chart.prototype._usingDisplayNameForSemantics = function(oVizProperties) {
		//check whether the parameter is undefined or null
		var isExist = function(o) {
			if ((typeof (o) === 'undefined') || (o === null)) {
				return false;
			}
			return true;
		};

		if (oVizProperties.plotArea && oVizProperties.plotArea.dataPointStyle && oVizProperties.plotArea.dataPointStyle.rules) {
			
			/*
			If semantic rules meet the following 4 conditions:
			(1) aRules[i].displayName === undefined : displayName isnt defined
			(2) akeys.length === 1 : Only one sematic rules condition;
			(3) oDataContext[key].hasOwnProperty("equal") == true : use equal label;
			(4) aVisibleDimensions.indexOf(key) !== -1 : the condition is for dimension;
			Then if the value of 'equal' is equal to some value in oBindingData, when meet the any of the following 2 conditions:
			(1) this.getDimensionByName(key).getTextProperty() === undefined
			(2) this.getDimensionByName(key).getDisplayText() === false
			set the corresponding value of 'equal' to the the rule's displayName. otherwise, set the displayText to the rule's displayName.
			Otherwise show the default "Semantic Range1".
			*/

			//currently, there are only two types of binding 
			var aContexts = this._getContexts();
			if (aContexts.length > 0 && !aContexts.hasOwnProperty("dataRequested")) {
				var aVisibleDimensions = this.getVisibleDimensions(),
					aRules = oVizProperties.plotArea.dataPointStyle.rules;
				for (var i = 0; i < aRules.length; i++) {
					var oDataContext = aRules[i].dataContext;
					if (oDataContext && oDataContext.length !== 0) {
						var akeys = Object.keys(oDataContext);
						if ( !isExist(aRules[i].displayName) && akeys.length === 1) {
							var key = akeys[0];
							if (oDataContext[key].hasOwnProperty("equal") && aVisibleDimensions.indexOf(key) !== -1) {
								var sTextProperty = this.getDimensionByName(key).getTextProperty();
								for (var j = 0; j < aContexts.length; j++) {
									if (aContexts[j].getProperty(key) === oDataContext[key].equal) {
										var sDisplayName = aContexts[j].getProperty(sTextProperty);
										if (!isExist(sTextProperty) || !isExist(sDisplayName) || typeof (sDisplayName) === "object" || this.getDimensionByName(key).getDisplayText() === false) {
											aRules[i].displayName = oDataContext[key].equal;
											break;
										} else {
											aRules[i].displayName = sDisplayName;
											break;
										}
									}
								}
							}
						}
					}
				}
			}	
		}
	};

	Chart.prototype._getCandidateColoringSetting = function() {
		if (!this._bColoringParsed) {
			this._bColoringParsed = true;
			this._oCandidateColoringSetting = {};
			var oColoring = this.getColorings();
			var oActiveColoring = this.getActiveColoring();
			var aMsrs = this._normalizeDorM(this.getVisibleMeasures());
			var aDims = this._normalizeDorM(this.getVisibleDimensions(), true);
			var aInResultDims = this._normalizeDorM(this.getInResultDimensions(), true);

			if (oColoring) {
				try {
					var sUrl = jQuery.sap.getResourcePath("sap/chart/i18n/i18n.properties");
					var oBundle = jQuery.sap.resources({
						url: sUrl
					});
					this._oCandidateColoringSetting = Colorings.getCandidateSetting(oColoring, oActiveColoring, aMsrs, aDims, aInResultDims, this._oColoringStatus || {}, this.getChartType(), oBundle);
					//use original chartType here since adapted chartType is not ready in some workflow
				} catch (e) {
					if (e instanceof ChartLog) {
						e.display();
					} else {
						throw e;
					}
				}
			}
		}
		return this._oCandidateColoringSetting;
	};


	// ---------------- Hosted VizProperties ----------------
	Chart.prototype._hostedVizProperties = {
		selectionMode: {prop: "interaction.selectability.mode"},
		selectionBehavior: {prop: "interaction.selectability.behavior"}
	};

	Chart.prototype._getHostedVizProperties = function() {
		return Object.keys(this._hostedVizProperties).reduce(function(obj, prop) {
			var oSubProp = this._hostedVizProperties[prop].prop.split(".").reverse().reduce(function(obj, path) {
				var result = {};
				result[path] = obj;
				return result;
			}, this.getProperty(prop));
			return jQuery.extend(true, obj, oSubProp);
		}.bind(this), {});

    };

	var FIORI_LABEL_SHORTFORMAT_10 = "__UI5__ShortIntegerMaxFraction10";
	var FIORI_LABEL_FORMAT_2 = "__UI5__FloatMaxFraction2";
	var FIORI_LABEL_SHORTFORMAT_2 = "__UI5__ShortIntegerMaxFraction2";
	Chart.prototype._getDefaultVizProperties = function() {
		// Use UI5 formatter by default in analytic chart
		var type = 'info/' + (this._sAdapteredChartType || this.getChartType());
		var bIsPercentage = (type.indexOf("info/100_") === 0);
		var bIsPie = (type === "info/pie" || type === "info/donut");
		var oDefaults = {
			interaction: {
				extraEventInfo: true
			}
		};
		return jQuery.extend(true, oDefaults,
							 applyDefaultFormatString({}, type,
													  ["valueAxis.label.formatString", "valueAxis2.label.formatString"],
													  bIsPercentage ? '' : FIORI_LABEL_SHORTFORMAT_10),
							 applyDefaultFormatString({}, type,
													  ["legend.formatString", "sizeLegend.formatString"],
													  FIORI_LABEL_SHORTFORMAT_2),
							 applyDefaultFormatString({}, type,
													  ["plotArea.dataLabel.formatString"],
													  bIsPie ? '' : FIORI_LABEL_SHORTFORMAT_2),
							 applyDefaultFormatString({}, type,
													  ["tooltip.formatString"],
													  bIsPercentage ? '' : FIORI_LABEL_FORMAT_2));

		function setPropertiesValue(properties, path, value) {
			if (path.length === 0) {
				return value;
			}
			properties = properties || {};
			var p = properties[path[0]];
			properties[path[0]] = setPropertiesValue(p, path.slice(1), value);
			return properties;
		}

		function getPropertiesDefination(propDef, path) {
			if (propDef == null || path.legnth === 0) {
				return propDef;
			}
			var e = propDef[path[0]];
			if (e && e.children) {
				return getPropertiesDefination(e.children, path.slice(1));
			}
			return e;
		}

		function applyDefaultFormatString(properties, chartType, formatStringPaths, formatString) {
			var metadata = sap.viz.api.metadata.Viz.get(chartType);
			if (metadata) {
				var propDef = metadata.properties;
				formatStringPaths.forEach(function(path) {
					path = path.split(".");
					var p = getPropertiesDefination(propDef, path);
					if (p && p.hasOwnProperty("defaultValue")) {
						setPropertiesValue(properties, path, formatString);
					}
				});
			}
			return properties;
		}
	};

	Chart.prototype._getPagingVizProperties = function() {
		if (this._isEnablePaging()) {
			var oPagingProperties = {
				interaction: {
					zoom: {
						enablement: false
					},
					selectability: {
						mode: "NONE"
					}
				},
				plotArea: {
					isFixedDataPointSize: true
				}
			};
			return oPagingProperties;
		} else {
			return {};
		}
	};

	Chart.prototype._getTimeProperties = function() {
		var aTimeLevels = ["year", "month", "day"]; //default value
		var oFiscalYearPeriodCount = null;  //default value
		var that = this;
		var sTimeDim = this.getVisibleDimensions().filter(function(sDim) {
			var oDim = that.getDimensionByName(sDim);
			return (oDim instanceof sap.chart.data.TimeDimension && oDim._getFixedRole() === "category");
		})[0];

		if (sTimeDim) {
			var oTimeDim = this.getDimensionByName(sTimeDim);
			switch (oTimeDim.getTimeUnit()) {
				case TimeUnitType.yearmonthday:
					aTimeLevels = ["year", "month", "day"];
					break;
				case TimeUnitType.yearquarter:
					aTimeLevels = ["year", "quarter"];
					break;
				case TimeUnitType.yearmonth:
					aTimeLevels = ["year", "month"];
					break;
				case TimeUnitType.fiscalyear:
					aTimeLevels = ["fiscal_year"];
					break;
				case TimeUnitType.fiscalyearperiod:
					aTimeLevels = ["fiscal_period", "fiscal_year"];
					break;
				default:
			}
			
			oFiscalYearPeriodCount = oTimeDim.getFiscalYearPeriodCount();
		}

		var oProps = this.getProperty("vizProperties");
		if (oProps && oProps.timeAxis) {
			// user properties have higher priority
			var timeAxis = oProps.timeAxis;
			if (timeAxis.levels) {
				aTimeLevels = timeAxis.levels;
			}
			if (timeAxis.fiscal && timeAxis.fiscal.periodNumbers) {
				oFiscalYearPeriodCount = timeAxis.fiscal.periodNumbers;
			}
		}

		return {
			"timeAxis": {
				"levels": aTimeLevels,
				"fiscal": {
					"periodNumbers": oFiscalYearPeriodCount
				}
			}
		};
	};

	Chart.prototype.setSelectionMode = function (oValue) {
		this.setProperty("selectionMode", oValue);
		var oVizFrame = this._getVizFrame();
		if (oVizFrame) {
			oVizFrame.setVizProperties({interaction: {selectability: {mode: oValue}}});
		}
		return this;
	};

	Chart.prototype.getSelectionMode = function () {
		var oVizFrame = this._getVizFrame();
		if (oVizFrame) {
			return oVizFrame.getVizProperties().interaction.selectability.mode;
		} else {
			return this.getProperty("selectionMode");
		}
	};

	Chart.prototype.setSelectionBehavior = function(oValue){
		this.setProperty("selectionBehavior", oValue);
		var oVizFrame = this._getVizFrame();
		if (oVizFrame) {
			oVizFrame.setVizProperties({interaction: {selectability: {behavior: oValue}}});
		}
		return this;
	};

	Chart.prototype.getSelectionBehavior = function () {
		var oVizFrame = this._getVizFrame();
		if (oVizFrame) {
			return oVizFrame.getVizProperties().interaction.selectability.behavior;
		} else {
			return this.getProperty("selectionBehavior");
		}
	};

	// ---------------- Public Helpers ----------------
	/**
	 * Return Dimension with the given name.
	 *
	 * @param {string} sName name of the Dimension to get
	 * @public
	 * @return {sap.chart.data.Dimension} Dimension of the specified name.
	 */
	Chart.prototype.getDimensionByName = function(sName) {
		return this.getDimensions().filter(function(d) {return d.getName() === sName;})[0];
	};
	/**
	 * Return Measure with the given name.
	 *
	 * @param {string} sName name of the Measure to get
	 * @public
	 * @return {sap.chart.data.Measure} Measure of the specified name.
	 */
	Chart.prototype.getMeasureByName = function(sName) {
		return this.getMeasures().filter(function(m) {return m.getName() === sName;})[0];
	};
	/**
	 * Return all TimeDimensions from current Dimensions.
	 *
	 * @public
	 * @return {array} Dimensions which are instance of TimeDimension.
	 */
	Chart.prototype.getTimeDimensions = function() {
		return this.getDimensions().filter(function(d) {return d instanceof TimeDimension;});
	};

	function scrollHandler(oEvent) {
		if (this._isEnablePaging() && this._bNeedPaging) {
			//var oVizFrame = this._getVizFrame();
			var ratio = oEvent.getParameters().position;
			this._updatePage(ratio);
		}
	}

	Chart.prototype._isEnablePaging = function() {
		this._bMobile = sap.ui.Device.system.tablet || sap.ui.Device.system.phone;
		var ret = this.getEnablePagination() && this._bIsPagingChartType && !this._bMobile;
		return ret;
	};

	Chart.prototype._updatePage = function(ratio) {
		var oVizFrame = this._getVizFrame();
		var iCurrentPageNo = Math.floor(this._iTotalSize * ratio / this._iPageSize);
		//we merge last two pages in case last page does not reach pageSize
		iCurrentPageNo = Math.min(iCurrentPageNo, this._iMaxPageNo);
		this._iOffset = null;

		var iStartIndex = Math.max((iCurrentPageNo - 1) * this._iPageSize, 0);
		var iLength, domain;

		if (iCurrentPageNo === 0) {
			iLength = this._iPageSize;
				domain = this._iPageSize;
		} else if (iCurrentPageNo === this._iMaxPageNo){
			iLength = this._iPageSize * 2 + this._iRemainingRecords;
			domain = this._iPageSize + this._iRemainingRecords;
		} else {
			iLength = this._iPageSize * 2;
			domain = this._iPageSize;
		}
		this._iOffset = (this._iTotalSize * ratio - iCurrentPageNo * this._iPageSize) / domain;

        var oDataset = this._getDataset();

		if (oDataset.getRenderedPageNo() === iCurrentPageNo) {
			//current page is rendered
			var translate = {
				plot: {
					transform: {
						translate: {
							translateByPage: {
								context: this._middleCtx,
								offset: this._iOffset
							}
						}
					}
				}
			};
			oVizFrame._states(translate);
			this._showLoading(false);
		} else {
			if (this._pagingTimer) {
				jQuery.sap.clearDelayedCall(this._pagingTimer);
			}
			this._pagingTimer = jQuery.sap.delayedCall(50, this, function() {
				this._oPagingOption = {
					bEnabled: true,
					iStartIndex: iStartIndex,
					iLength: iLength,
					sMode: "update",
					thumbRatio: null,
					iPageNo: iCurrentPageNo
				};
				var aContexts = this.getBinding("data").getContexts(iStartIndex, iLength),
				bNoContexts;
				if (aContexts.dataRequested) {
					bNoContexts = true;
				} else {
					bNoContexts = aContexts.some(function(oContext) {
						return oContext === undefined;
					});
				}
				if (bNoContexts) {
					//need request new data
					oDataset.suppressInvalidate();
				} else {
					//analytical binding has these data in local
					//current page is not rendered
					oDataset.setPagingOption(this._oPagingOption);
					oDataset.updateData();
					oVizFrame.invalidate();
					this._oColorTracker.add(this._getVizFrame()._runtimeScales());
					this._getVizFrame()._runtimeScales(this._oColorTracker.get(), true);
				}
			});
			this._sLoadingTimer = this._sLoadingTimer || jQuery.sap.delayedCall(200, this, function() {
				this._showLoading(true);
			});
		}
	};

	function vizFrameRenderCompleteHandler(oEvent) {
		var oParameters = oEvent.getParameters();
		delete oParameters.id;

		if (this._isEnablePaging() && this._bNeedPaging) {
			if (this._sLoadingTimer) {
				jQuery.sap.clearDelayedCall(this._sLoadingTimer);
                this._sLoadingTimer = null;
			}
			var oVizFrame = this._getVizFrame();
			var oBinding = this.getBinding("data");
			var oDataset = this._getDataset();
			var iRenderedPageNo = oDataset.getRenderedPageNo();
			if (iRenderedPageNo !==  0) {
				var iMidRecordNo = iRenderedPageNo * this._iPageSize - 1;
				this._middleCtx = oBinding.getContexts(iMidRecordNo, 1)[0].getObject();
			} else {
				this._middleCtx = null;
			}
			if (this._middleCtx || this._iOffset) {
					var translate = {
							plot: {
								transform: {
									translate: {
										translateByPage: {
											context: this._middleCtx,
											offset: this._iOffset
										}
									}
								}
							}
						};
				oVizFrame._states(translate);
			}
			this._showLoading(false);
		}

		this.fireEvent("renderComplete", oParameters);
	}

	/*
	 * TODO: Comment this function later
	 * debug function to draw page scale on scroll bar
	 */
//		Chart.prototype._drawPageScale = function() {
//			var dataLength = this._iTotalSize;
//			var pageLength = this._iPageSize;
//				var thumb = $(".v-m-scrollbarThumb")[0].getBoundingClientRect();
//				var track = $(".v-m-scrollbarTrack")[0].getBoundingClientRect();
//
//				for (var i = 0; i * pageLength < dataLength; ++i) {
//						var line = $("<line>");
//						$("body").append(line);
//						line.css({
//								position: "absolute",
//								"background-color": "red",
//								width: 1,
//								height: thumb.height,
//								left: thumb.right + i * pageLength / dataLength * (track.width - thumb.width),
//								top: thumb.top
//						});
//				}
//		};

	Chart.prototype._showLoading = function(bLoading) {
		var $this = this.$();
		if (!$this) {
			return;
		}

		if (!bLoading) {
			if (this._$loadingIndicator) {
				this._$loadingIndicator.remove();
			}
		} else {
			if (!this._$loadingIndicator) {
				this._$loadingIndicator = this._createLoadingIndicator();
			}
			this._updateLoadingIndicator();
			$this.append(this._$loadingIndicator);
		}
		this._bLoading = bLoading;
	};

	Chart.prototype._createLoadingIndicator = function() {
		var $indicator = jQuery(sap.ui.core.BusyIndicatorUtils.getElement());
		var $text = jQuery("<p>").attr("class", "loading-text").text("Loading");
		$text.css({
			"position": "absolute",
			"transform": "translateY(-3em)",
			"width": "100%",
			"text-align": "center"
		});
		$text.insertBefore($indicator.children()[0]);
		$indicator.css({opacity: 1});
		return $indicator;
	};

	Chart.prototype._updateLoadingIndicator = function() {
		var $this = this.$();
		if (!$this || !this._$loadingIndicator) {
			return;
		}
		var sChartType = this._sAdapteredChartType,
			bHorizontal = sChartType === "bar" || sChartType.indexOf("horizontal") !== -1;
		var $plot = $this.find(".v-plot-bound"),

			oThisOffset = $this.offset(),
			oPosition = {
				top: oThisOffset.top,
				left: oThisOffset.left,
				width: $this.width(),
				height: $this.height()
			};

		if ($plot.length) {
			var oPlotOffset = $plot.offset(),
				oPlotBound = $plot[0].getBoundingClientRect(); // jQuery returns 0 for width/height of this element somehow
			oPosition.top = oPlotOffset.top - 1;
			oPosition.left = oPlotOffset.left;

			oPosition.width = oPlotBound.width + 1;
			if (bHorizontal) {
				oPosition.height = Math.ceil(oPlotBound.height + 1);
			} else {
				oPosition.height = Math.floor(oPlotBound.height + 1);
			}
		}
		this._$loadingIndicator.css(oPosition);

		var $text = this._$loadingIndicator.find(".loading-text");
		//var $next = $text.next();
		$text.css({
			"top": oPosition.height / 2,
			"font-weight": sap.ui.core.theming.Parameters.get("sapUiChartTitleFontWeight"),
			"font-size": sap.ui.core.theming.Parameters.get("sapUiChartMainTitleFontSize"),
			"color": sap.ui.core.theming.Parameters.get("sapUiChartMainTitleFontSize")
		});

		this._$loadingIndicator.css({
			"background-color": sap.ui.core.theming.Parameters.get("sapUiExtraLightBG")
		});
	};

	Chart.prototype._getRequiredDimensions = function() {
		var aVisDims = this._getVisibleDimensions(),
			aInResultDims = this.getInResultDimensions();
		return this._normalizeDorM(aVisDims.concat(aInResultDims), true);
	};

	Chart.prototype._getRequiredMeasures = function() {
		return this._getVisibleMeasures(true);
	};

	// Request for the min/max at current aggregation level for all visible measures
	Chart.prototype._queryMinMax = function(fnCallback) {
		var aDims = this._getRequiredDimensions().map(function(oDim) {
				return oDim.getName();
			}),
			aMsrs = this._getRequiredMeasures().map(function(oMsr) {
				return oMsr.getName();
			});

		var oResult = aMsrs.reduce(function(oResult, sMsr) {
			oResult[sMsr] = {min: {}, max: {}};
			return oResult;
		}, {});

		function checkComplete() {
			var bAllComplete = aMsrs.every(function(sMsr) {
				return oResult[sMsr].min.requested && oResult[sMsr].max.requested;
			});
			if (bAllComplete) {
				fnCallback(oResult);
			}
		}

		function onsuccess(sMsr, sKey, oData) {
			oResult[sMsr][sKey].requested = true;
			oResult[sMsr][sKey].value = parseFloat(oData && oData.results[0][sMsr]);
			checkComplete();
		}

		function onerror(sMsr, sKey, oData) {
			oResult[sMsr][sKey].requested = true;
			oResult[sMsr][sKey].error = oData;
			checkComplete();
		}

		var aQueries = aMsrs.reduce(function(aQueries, sMsr) {
			return aQueries.concat({
				urlParameters: {
					"$select": aDims.concat(sMsr).join(","),
					"$top": 1,
					"$orderby": sMsr + " asc"
				},
				success: onsuccess.bind(null, sMsr, "min"),
				error: onerror.bind(null, sMsr, "min")
			}, {
				urlParameters: {
					"$select": aDims.concat(sMsr).join(","),
					"$top": 1,
					"$orderby": sMsr + " desc"
				},
				success: onsuccess.bind(null, sMsr, "max"),
				error: onerror.bind(null, sMsr, "max")
			});
		}, []);

		var oBinding = this.getBinding("data"),
			sPath = oBinding.getPath(),
			oModel = oBinding.getModel();
		aQueries.forEach(function(oQuery) {
			oModel.read(sPath, oQuery);
		});

		return aQueries;
    };

	Chart.prototype._measureRangeReceivedHandler = function(oQueryResult) {
		var mMeasureRange = {};
		jQuery.each(oQueryResult, function(sMsrId, oResult) {
			mMeasureRange[sMsrId] = {
					min: oResult.min.value,
					max: oResult.max.value
			};
		});
		this._mMeasureRange = mMeasureRange;
		var oVizFrame = this._getVizFrame();
		oVizFrame._pendingDataRequest(false);
		this._invalidateBy({
			source: this,
			keys: {
				vizFrame: true
			}
		});
		this.setBusy(false);
	};

	/**
     * Export the current chart as SVG String.
     * The chart is ready to be exported to SVG ONLY after the initialization is finished.
     * Any attempt to export to SVG before that will result in an empty SVG string.
     * @public
     * @param {Object} [option]
     * <pre>
     * {
     *     width: Number - the exported svg will be scaled to the specific width.
     *     height: Number - the exported svg will be scaled to the specific height.
     *     hideTitleLegend: Boolean - flag to indicate if the exported SVG includes the original title and legend.
     *     hideAxis: Boolean - flag to indicate if the exported SVG includes the original axis.
     * }
     * </pre>
     * @return {string} the SVG string of the current viz or empty svg if error occurs.
     */
	Chart.prototype.exportToSVGString = function(option) {
		var sSVGString = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\"/>",
			oVizFrame = this._getVizFrame();
		if (oVizFrame) {
			sSVGString = oVizFrame.exportToSVGString(option);
		}
		return sSVGString;
	};

	return Chart;
});

}; // end of sap/chart/Chart.js
